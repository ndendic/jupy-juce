<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Dependencies ‚Äì jupy-juice</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ebc57992554dae5230fa85c1bd5a55fa.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Dependencies ‚Äì jupy-juice">
<meta property="og:description" content="Wrapper for SQLModel in FastHTML">
<meta property="og:site_name" content="jupy-juice">
<meta name="twitter:title" content="Dependencies ‚Äì jupy-juice">
<meta name="twitter:description" content="Wrapper for SQLModel in FastHTML">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">jupy-juice</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./core.html">Dependencies</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">üçä Jupy-Juice</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./core.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Dependencies</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#agent-setup" id="toc-agent-setup" class="nav-link active" data-scroll-target="#agent-setup">Agent setup</a>
  <ul class="collapse">
  <li><a href="#get_current_agent" id="toc-get_current_agent" class="nav-link" data-scroll-target="#get_current_agent">get_current_agent</a></li>
  <li><a href="#agent-tools" id="toc-agent-tools" class="nav-link" data-scroll-target="#agent-tools">Agent tools</a>
  <ul class="collapse">
  <li><a href="#create-cell-tool" id="toc-create-cell-tool" class="nav-link" data-scroll-target="#create-cell-tool">Create cell tool</a></li>
  <li><a href="#create_cell" id="toc-create_cell" class="nav-link" data-scroll-target="#create_cell">create_cell</a></li>
  <li><a href="#set_agent" id="toc-set_agent" class="nav-link" data-scroll-target="#set_agent">set_agent</a></li>
  <li><a href="#adding-notebook-history" id="toc-adding-notebook-history" class="nav-link" data-scroll-target="#adding-notebook-history">Adding notebook history</a></li>
  <li><a href="#find_current_notebook" id="toc-find_current_notebook" class="nav-link" data-scroll-target="#find_current_notebook">find_current_notebook</a></li>
  <li><a href="#get_notebook_history" id="toc-get_notebook_history" class="nav-link" data-scroll-target="#get_notebook_history">get_notebook_history</a></li>
  <li><a href="#creating-history-aware-prompt" id="toc-creating-history-aware-prompt" class="nav-link" data-scroll-target="#creating-history-aware-prompt">Creating history-aware prompt</a></li>
  <li><a href="#create_history_aware_prompt" id="toc-create_history_aware_prompt" class="nav-link" data-scroll-target="#create_history_aware_prompt">create_history_aware_prompt</a></li>
  <li><a href="#running-agent-with-notebook-history" id="toc-running-agent-with-notebook-history" class="nav-link" data-scroll-target="#running-agent-with-notebook-history">Running agent with notebook history</a></li>
  <li><a href="#run_with_history" id="toc-run_with_history" class="nav-link" data-scroll-target="#run_with_history">run_with_history</a></li>
  <li><a href="#creating-prompt-cell-magic" id="toc-creating-prompt-cell-magic" class="nav-link" data-scroll-target="#creating-prompt-cell-magic">Creating prompt cell magic</a></li>
  <li><a href="#prompt" id="toc-prompt" class="nav-link" data-scroll-target="#prompt">prompt</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/ndendic/jupy-juice/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div><div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="core.html.md"><i class="bi bi-file-code"></i>CommonMark</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Dependencies</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="agent-setup" class="level1">
<h1>Agent setup</h1>
<p>System prompt</p>
<hr>
<p><a href="https://github.com/ndendic/jupy-juice/blob/main/jupy_juice/core.py#L41" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="get_current_agent" class="level3">
<h3 class="anchored" data-anchor-id="get_current_agent">get_current_agent</h3>
<blockquote class="blockquote">
<pre><code> get_current_agent ()</code></pre>
</blockquote>
<p><em>Get the current agent, falling back to default notebook_agent if none set.</em></p>
</section>
<section id="agent-tools" class="level2">
<h2 class="anchored" data-anchor-id="agent-tools">Agent tools</h2>
<section id="create-cell-tool" class="level3">
<h3 class="anchored" data-anchor-id="create-cell-tool">Create cell tool</h3>
<hr>
<p><a href="https://github.com/ndendic/jupy-juice/blob/main/jupy_juice/core.py#L52" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="create_cell" class="level3">
<h3 class="anchored" data-anchor-id="create_cell">create_cell</h3>
<blockquote class="blockquote">
<pre><code> create_cell (ctx:pydantic_ai.tools.RunContext[str], content:str,
              cell_type:Literal['code','markdown']='code')</code></pre>
</blockquote>
<p>*Create a new cell in the notebook with the specified content.</p>
<p>Args: content: The content to put in the new cell cell_type: Type of cell to create (‚Äòcode‚Äô or ‚Äòmarkdown‚Äô)</p>
<p>Returns: A confirmation message*</p>
<p>Always set custom agents to inherit base tools</p>
<hr>
<p><a href="https://github.com/ndendic/jupy-juice/blob/main/jupy_juice/core.py#L77" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="set_agent" class="level3">
<h3 class="anchored" data-anchor-id="set_agent">set_agent</h3>
<blockquote class="blockquote">
<pre><code> set_agent (agent:pydantic_ai.agent.Agent)</code></pre>
</blockquote>
<p>*Set a custom agent for the notebook.</p>
<p>Args: agent: PydanticAI agent instance</p>
<p>Returns: Configured agent with required tools*</p>
<p>Tool testing cell creation tool</p>
<div id="cell-11" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> notebook_agent.run_sync(<span class="st">'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?'</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>Markdown(result.data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display cell-output-markdown">
<p>I have created a new cell with a simple ‚ÄúHello, World!‚Äù function. You can run it to see the output.</p>
</div>
</div>
<div id="cell-12" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hello_world():</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Hello, World!"</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>hello_world()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-13" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> notebook_agent.run_sync(<span class="st">"Create a function that calculates the factorial of a number with input validation"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>Markdown(result.data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display cell-output-markdown">
<p>I created a function that calculates the factorial of a number with input validation. You can test it in the new cell provided.</p>
</div>
</div>
<div id="cell-14" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> factorial(n):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculate the factorial of a non-negative integer n.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">    n (int): A non-negative integer whose factorial is to be computed</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">    int: Factorial of the input number n</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input validation</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(n, <span class="bu">int</span>):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">"Input must be an integer"</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input must be a non-negative integer"</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: factorial of 0 is 1</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recursive case: n! = n * (n-1)!</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Testing agent with history</p>
<div id="cell-16" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> notebook_agent.run_sync(<span class="st">'So what you just made for me here?'</span>, message_history<span class="op">=</span>result.new_messages())</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>Markdown(result.data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display cell-output-markdown">
<p>I created a Python function named <code>factorial</code> that calculates the factorial of a non-negative integer. The function includes input validation to ensure that the input is a non-negative integer. If the input is not an integer or is negative, the function raises a <code>ValueError</code> with an appropriate message.</p>
<p>Here‚Äôs a summary of the key parts of the code:</p>
<ul>
<li><strong>Input Validation</strong>:
<ul>
<li>Checks if <code>n</code> is an integer. If not, it raises a <code>ValueError</code>.</li>
<li>Checks if <code>n</code> is a non-negative integer. If <code>n</code> is negative, it raises a <code>ValueError</code>.</li>
</ul></li>
<li><strong>Factorial Calculation</strong>:
<ul>
<li>Uses an iterative approach to calculate the factorial.</li>
<li>Returns <code>1</code> if <code>n</code> is <code>0</code> (the factorial of 0 is 1).</li>
<li>Uses a for-loop to compute the factorial for positive integers.</li>
</ul></li>
<li><strong>Example Usage</strong>:
<ul>
<li>Demonstrates the function by calculating the factorial of 5.</li>
<li>Includes a try-except block to catch and print the error message if a <code>ValueError</code> is raised when computing the factorial of a negative number.</li>
</ul></li>
</ul>
<p>You can execute the cell to see how it works or modify it to test with other values.</p>
</div>
</div>
<div id="cell-17" class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>result.all_messages()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>[ModelRequest(parts=[SystemPromptPart(content="\nYou are a helpful assistant that operates in a Jupyter notebook.\nYour regular text responses are rendered as cell output.\nYou can create new cells, edit existing cells, and run code.\nYou can also use tools to help you with your tasks.\nToday's date is 2024-12-31.\n", part_kind='system-prompt'), UserPromptPart(content='Create a function that calculates the factorial of a number with input validation', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 43, 700768, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[ToolCallPart(tool_name='create_cell', args=ArgsJson(args_json='{"content":"def factorial(n):\\n    \\"\\"\\"\\n    Calculate the factorial of a non-negative integer n.\\n    \\n    :param n: non-negative integer\\n    :return: factorial of n\\n    \\"\\"\\"\\n    # Input validation\\n    if not isinstance(n, int):\\n        raise ValueError(\\"Input must be an integer.\\")\\n    if n &lt; 0:\\n        raise ValueError(\\"Input must be a non-negative integer.\\")\\n    \\n    # Base case\\n    if n == 0:\\n        return 1\\n    \\n    # Recursive case\\n    result = 1\\n    for i in range(1, n + 1):\\n        result *= i\\n    return result\\n\\n# Example usage\\ntry:\\n    print(factorial(5))  # Should print 120\\n    print(factorial(-1)) # Should raise a ValueError\\nexcept ValueError as e:\\n    print(e)","cell_type":"code"}'), tool_call_id='call_dP852a9HSFo4HgyvUTm6NtHd', part_kind='tool-call')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 44, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[ToolReturnPart(tool_name='create_cell', content='Created new code  with content: def factorial(n):\n    """\n    Calculate the factorial of a non-negative integer n.\n    \n    :param n: non-negative integer\n    :return: factorial of n\n    """\n    # Input validation\n    if not isinstance(n, int):\n        raise ValueError("Input must be an integer.")\n    if n &lt; 0:\n        raise ValueError("Input must be a non-negative integer.")\n    \n    # Base case\n    if n == 0:\n        return 1\n    \n    # Recursive case\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n# Example usage\ntry:\n    print(factorial(5))  # Should print 120\n    print(factorial(-1)) # Should raise a ValueError\nexcept ValueError as e:\n    print(e)', tool_call_id='call_dP852a9HSFo4HgyvUTm6NtHd', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 47, 279330, tzinfo=datetime.timezone.utc), part_kind='tool-return')], kind='request'),
 ModelResponse(parts=[TextPart(content='I created a function that calculates the factorial of a number with input validation. You can test it in the new cell provided.', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[UserPromptPart(content='So what you just made for me here?', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, 46240, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. The function includes input validation to ensure that the input is a non-negative integer. If the input is not an integer or is negative, the function raises a `ValueError` with an appropriate message. \n\nHere's a summary of the key parts of the code:\n\n- **Input Validation**: \n  - Checks if `n` is an integer. If not, it raises a `ValueError`.\n  - Checks if `n` is a non-negative integer. If `n` is negative, it raises a `ValueError`.\n\n- **Factorial Calculation**: \n  - Uses an iterative approach to calculate the factorial.\n  - Returns `1` if `n` is `0` (the factorial of 0 is 1).\n  - Uses a for-loop to compute the factorial for positive integers.\n\n- **Example Usage**: \n  - Demonstrates the function by calculating the factorial of 5.\n  - Includes a try-except block to catch and print the error message if a `ValueError` is raised when computing the factorial of a negative number.\n\nYou can execute the cell to see how it works or modify it to test with other values.", part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, tzinfo=datetime.timezone.utc), kind='response')]</code></pre>
</div>
</div>
</section>
<section id="adding-notebook-history" class="level3">
<h3 class="anchored" data-anchor-id="adding-notebook-history">Adding notebook history</h3>
<hr>
<p><a href="https://github.com/ndendic/jupy-juice/blob/main/jupy_juice/core.py#L105" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="find_current_notebook" class="level3">
<h3 class="anchored" data-anchor-id="find_current_notebook">find_current_notebook</h3>
<blockquote class="blockquote">
<pre><code> find_current_notebook ()</code></pre>
</blockquote>
<p>*Find and cache the current notebook data.</p>
<p>Returns: Dict containing notebook data or None if not found*</p>
<hr>
<p><a href="https://github.com/ndendic/jupy-juice/blob/main/jupy_juice/core.py#L158" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="get_notebook_history" class="level3">
<h3 class="anchored" data-anchor-id="get_notebook_history">get_notebook_history</h3>
<blockquote class="blockquote">
<pre><code> get_notebook_history (max_cells:int=10)</code></pre>
</blockquote>
<p>*Get the content of notebook cells between current and last prompt cell.</p>
<p>Args: max_cells: Maximum number of previous cells to include</p>
<p>Returns: List of previous cell contents*</p>
<p>Testing notebook history</p>
<div id="cell-22" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>nb_hist <span class="op">=</span> get_notebook_history(max_cells<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>nb_hist</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>["Cell[7]:\nSource:\n#| export\nfrom typing import cast\nmodel = cast(KnownModelName, os.getenv('PYDANTIC_AI_MODEL', 'openai:gpt-4o'))\nprint(f'PydanticAI is using model: {model}')\nnotebook_agent = Agent(model, system_prompt=system_prompt)\nOutputs:\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['PydanticAI is using model: openai:gpt-4o\\n']}]",
 'Cell[8]:\nSource:\n#| export\n_current_agent: Optional[Agent] = None\n\ndef get_current_agent() -&gt; Agent:\n    """Get the current agent, falling back to default notebook_agent if none set."""\n    global _current_agent, notebook_agent\n    return _current_agent or notebook_agent\n\nOutputs:\n[]',
 'Cell[9]:\nSource:\n## Agent tools\nOutputs:\nNone',
 'Cell[10]:\nSource:\n### Create cell tool\nOutputs:\nNone',
 'Cell[11]:\nSource:\n#| export\nfrom IPython.display import display, Markdown\nfrom typing import Literal\n\n@notebook_agent.tool\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\'code\', \'markdown\'] = \'code\') -&gt; str:\n    """Create a new cell in the notebook with the specified content.\n    \n    Args:\n        content: The content to put in the new cell\n        cell_type: Type of cell to create (\'code\' or \'markdown\')\n    \n    Returns:\n        A confirmation message\n    """\n    try:    \n        ipython = get_ipython()\n    except NameError:\n        return "Error: Not running in IPython/Jupyter environment"\n    \n    # Display the content immediately\n    if cell_type == \'code\':\n        # Set up the next cell with the content\n        ipython.set_next_input(content)\n    else:\n        display(Markdown(content))\n    \n    return f"Created new {cell_type}  with content: {content}"\nOutputs:\n[{\'name\': \'stderr\', \'output_type\': \'stream\', \'text\': [\'&lt;module&gt;:8: No type or annotation for returned value 1\\n\']}]',
 'Cell[12]:\nSource:\nAlways set custom agents to inherit base tools\n\nOutputs:\nNone',
 'Cell[13]:\nSource:\n#| export\ndef set_agent(agent: Agent) -&gt; Agent:\n    """Set a custom agent for the notebook.\n    \n    Args:\n        agent: PydanticAI agent instance\n        \n    Returns:\n        Configured agent with required tools\n    """\n    global _current_agent, notebook_agent\n        \n    # Always ensure create_cell tool is available\n    if \'create_cell\' not in agent._function_tools:\n        # Copy the tool directly from notebook_agent\n        agent._function_tools = notebook_agent._function_tools\n    \n    _current_agent = agent\n    return agent\nOutputs:\n[]',
 'Cell[14]:\nSource:\nTool testing cell creation tool\nOutputs:\nNone',
 'Cell[15]:\nSource:\nresult = notebook_agent.run_sync(\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\')\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I\\\'ve created a new cell with a simple "Hello, World!" function. You can run it to see the output.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 10, \'metadata\': {}, \'output_type\': \'execute_result\'}]',
 'Cell[16]:\nSource:\ndef hello_world():\n    print("Hello, world!")\n\nhello_world()\nOutputs:\n[]',
 'Cell[17]:\nSource:\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 12, \'metadata\': {}, \'output_type\': \'execute_result\'}]',
 'Cell[18]:\nSource:\ndef factorial(n):\n    """\n    Calculate the factorial of a non-negative integer n.\n\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed\n\n    Returns:\n    int: Factorial of the input number n\n    """\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError("Input must be an integer")\n    if n &lt; 0:\n        raise ValueError("Input must be a non-negative integer")\n\n    # Base case: factorial of 0 is 1\n    if n == 0:\n        return 1\n\n    # Recursive case: n! = n * (n-1)!\n    return n * factorial(n - 1)\nOutputs:\n[]',
 'Cell[19]:\nSource:\nTesting agent with history\nOutputs:\nNone',
 'Cell[20]:\nSource:\nresult = notebook_agent.run_sync(\'So what you just made for me here?\', message_history=result.new_messages())\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\n\', \'\\n\', "Here\'s a summary of what the function does:\\n", \'- It checks if the input is an integer. If not, it raises a `ValueError`.\\n\', "- It checks if the input is a non-negative integer. If it\'s negative, it raises a `ValueError`.\\n", \'- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\n\', \'- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 14, \'metadata\': {}, \'output_type\': \'execute_result\'}]',
 'Cell[21]:\nSource:\nresult.all_messages()\nOutputs:\n[{\'data\': {\'text/plain\': [\'[ModelRequest(parts=[SystemPromptPart(content="\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\'s date is 2024-12-31.\\\\n", part_kind=\\\'system-prompt\\\'), UserPromptPart(content=\\\'Create a function that calculates the factorial of a number with input validation\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 28, 691513, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', \' ModelResponse(parts=[ToolCallPart(tool_name=\\\'create_cell\\\', args=ArgsJson(args_json=\\\'{"content":"def factorial(n):\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\\\\\n    :param n: non-negative integer\\\\\\\\n    :return: factorial of n\\\\\\\\n    :raises ValueError: if n is not a non-negative integer\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    if not isinstance(n, int):\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be an integer\\\\\\\\")\\\\\\\\n    if n &lt; 0:\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be a non-negative integer\\\\\\\\")\\\\\\\\n    if n == 0 or n == 1:\\\\\\\\n        return 1\\\\\\\\n    result = 1\\\\\\\\n    for i in range(2, n + 1):\\\\\\\\n        result *= i\\\\\\\\n    return result","cell_type":"code"}\\\'), tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', part_kind=\\\'tool-call\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 29, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[ToolReturnPart(tool_name=\\\'create_cell\\\', content=\\\'Created new code  with content: def factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\n    :param n: non-negative integer\\\\n    :return: factorial of n\\\\n    :raises ValueError: if n is not a non-negative integer\\\\n    """\\\\n    if not isinstance(n, int):\\\\n        raise ValueError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n    if n == 0 or n == 1:\\\\n        return 1\\\\n    result = 1\\\\n    for i in range(2, n + 1):\\\\n        result *= i\\\\n    return result\\\', tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 32, 646314, tzinfo=datetime.timezone.utc), part_kind=\\\'tool-return\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what you just made for me here?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, 948002, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\\\n\\\\nHere\\\'s a summary of what the function does:\\\\n- It checks if the input is an integer. If not, it raises a `ValueError`.\\\\n- It checks if the input is a non-negative integer. If it\\\'s negative, it raises a `ValueError`.\\\\n- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\\\n- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.", part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 34, tzinfo=datetime.timezone.utc), kind=\\\'response\\\')]\']}, \'execution_count\': 15, \'metadata\': {}, \'output_type\': \'execute_result\'}]',
 'Cell[22]:\nSource:\n\nOutputs:\nNone',
 'Cell[23]:\nSource:\n### Adding notebook history\nOutputs:\nNone',
 'Cell[24]:\nSource:\n#| export\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\n\n# Cache for notebook data\n_notebook_cache: Dict[str, Any] = {}\n\ndef find_current_notebook() -&gt; Optional[dict]:\n    """Find and cache the current notebook data.\n    \n    Returns:\n        Dict containing notebook data or None if not found\n    """\n    global _notebook_cache\n    \n    try:\n        ipython = get_ipython()\n        if not ipython:\n            return None\n            \n        # Get current cell content to identify the notebook\n        current_cell = ipython.get_parent()[\'content\'][\'code\']\n        \n        # Check if we already found the notebook\n        if \'notebook\' in _notebook_cache:\n            # Verify it\'s still the correct notebook by checking the current cell\n            notebook = _notebook_cache[\'notebook\']\n            for cell in notebook[\'cells\']:\n                if (cell[\'cell_type\'] == \'code\' and \n                    \'\'.join(cell[\'source\']) == current_cell):\n                    return notebook\n        \n        # If not in cache or cache is invalid, search for the notebook\n        current_dir = Path.cwd()\n        notebook_files = list(current_dir.glob("*.ipynb"))\n        \n        for nb_file in notebook_files:\n            try:\n                with open(nb_file) as f:\n                    notebook = json.load(f)\n                    for cell in notebook[\'cells\']:\n                        if (cell[\'cell_type\'] == \'code\' and \n                            \'\'.join(cell[\'source\']) == current_cell):\n                            # Found the notebook, cache it\n                            _notebook_cache[\'notebook\'] = notebook\n                            _notebook_cache[\'file\'] = nb_file\n                            return notebook\n            except Exception:\n                continue\n                \n        return None\n        \n    except Exception as e:\n        print(f"Error finding notebook: {e}")\n        return None\n\nOutputs:\n[]',
 'Cell[25]:\nSource:\n#| export\nmax_lookback = 10\n\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\n    """Get the content of notebook cells between current and last prompt cell.\n    \n    Args:\n        max_cells: Maximum number of previous cells to include\n        \n    Returns:\n        List of previous cell contents\n    """\n    try:\n        # Get the cached notebook or find it\n        notebook = find_current_notebook()\n        if not notebook:\n            return []\n            \n        # Find current cell index\n        current_cell = get_ipython().get_parent()[\'content\'][\'code\']\n        cells = notebook[\'cells\']\n        current_idx = -1\n        last_prompt_idx = -1\n        \n        # Find current cell and last prompt cell\n        for idx, cell in enumerate(cells):\n            source = \'\'.join(cell[\'source\']) if isinstance(cell[\'source\'], list) else cell[\'source\']\n            \n            # Find current cell\n            if current_idx == -1 and cell[\'cell_type\'] == \'code\' and source == current_cell:\n                current_idx = idx\n                \n            # Find last prompt cell before current cell\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\n                if cell[\'cell_type\'] == \'code\' and source.strip().startswith(\'%%prompt\'):\n                    last_prompt_idx = idx\n                \n        if current_idx == -1:\n            return []\n            \n        # Get cells between last prompt and current cell\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\n        history = []\n        \n        for idx in range(start_idx, current_idx):\n            cell = cells[idx]            \n            source = cell[\'source\'] if isinstance(cell[\'source\'], str) else \'\'.join(cell[\'source\'])\n            if \'outputs\' in cell:\n                outputs = cell[\'outputs\'] if isinstance(cell[\'outputs\'], str) else str(cell[\'outputs\'])\n            else:\n                outputs = \'None\'\n            if not (source.strip().startswith(\'%%prompt\') or outputs.strip().startswith(\'#|exclude\') or outputs.strip().startswith(\'#| exclude\')):\n                history.append(f"Cell[{idx}]:\\nSource:\\n{source}\\nOutputs:\\n{outputs}")\n        \n        return history\n        \n    except Exception as e:\n        print(f"Error getting notebook history: {e}")\n        return []\nOutputs:\n[]',
 'Cell[26]:\nSource:\nTesting notebook history\nOutputs:\nNone']</code></pre>
</div>
</div>
</section>
<section id="creating-history-aware-prompt" class="level3">
<h3 class="anchored" data-anchor-id="creating-history-aware-prompt">Creating history-aware prompt</h3>
<hr>
<p><a href="https://github.com/ndendic/jupy-juice/blob/main/jupy_juice/core.py#L216" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="create_history_aware_prompt" class="level3">
<h3 class="anchored" data-anchor-id="create_history_aware_prompt">create_history_aware_prompt</h3>
<blockquote class="blockquote">
<pre><code> create_history_aware_prompt (prompt:str, message_history:list=None,
                              max_history:int=5)</code></pre>
</blockquote>
<p>*Create a prompt with notebook history context and message history.</p>
<p>Args: prompt: The user‚Äôs prompt message_history: Previous conversation messages from results.all_messages() max_history: Maximum number of previous cells to include</p>
<p>Returns: Tuple of (enhanced prompt, combined message history)*</p>
<p>Testing history-aware prompt</p>
<div id="cell-26" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>create_history_aware_prompt(<span class="st">'So what you just made for me here?'</span>, result.all_messages(), max_history<span class="op">=</span><span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>('So what you just made for me here?',
 [ModelRequest(parts=[SystemPromptPart(content="\nYou are a helpful assistant that operates in a Jupyter notebook.\nYour regular text responses are rendered as cell output.\nYou can create new cells, edit existing cells, and run code.\nYou can also use tools to help you with your tasks.\nToday's date is 2024-12-31.\n", part_kind='system-prompt'), UserPromptPart(content='Create a function that calculates the factorial of a number with input validation', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 43, 700768, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
  ModelResponse(parts=[ToolCallPart(tool_name='create_cell', args=ArgsJson(args_json='{"content":"def factorial(n):\\n    \\"\\"\\"\\n    Calculate the factorial of a non-negative integer n.\\n    \\n    :param n: non-negative integer\\n    :return: factorial of n\\n    \\"\\"\\"\\n    # Input validation\\n    if not isinstance(n, int):\\n        raise ValueError(\\"Input must be an integer.\\")\\n    if n &lt; 0:\\n        raise ValueError(\\"Input must be a non-negative integer.\\")\\n    \\n    # Base case\\n    if n == 0:\\n        return 1\\n    \\n    # Recursive case\\n    result = 1\\n    for i in range(1, n + 1):\\n        result *= i\\n    return result\\n\\n# Example usage\\ntry:\\n    print(factorial(5))  # Should print 120\\n    print(factorial(-1)) # Should raise a ValueError\\nexcept ValueError as e:\\n    print(e)","cell_type":"code"}'), tool_call_id='call_dP852a9HSFo4HgyvUTm6NtHd', part_kind='tool-call')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 44, tzinfo=datetime.timezone.utc), kind='response'),
  ModelRequest(parts=[ToolReturnPart(tool_name='create_cell', content='Created new code  with content: def factorial(n):\n    """\n    Calculate the factorial of a non-negative integer n.\n    \n    :param n: non-negative integer\n    :return: factorial of n\n    """\n    # Input validation\n    if not isinstance(n, int):\n        raise ValueError("Input must be an integer.")\n    if n &lt; 0:\n        raise ValueError("Input must be a non-negative integer.")\n    \n    # Base case\n    if n == 0:\n        return 1\n    \n    # Recursive case\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n# Example usage\ntry:\n    print(factorial(5))  # Should print 120\n    print(factorial(-1)) # Should raise a ValueError\nexcept ValueError as e:\n    print(e)', tool_call_id='call_dP852a9HSFo4HgyvUTm6NtHd', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 47, 279330, tzinfo=datetime.timezone.utc), part_kind='tool-return')], kind='request'),
  ModelResponse(parts=[TextPart(content='I created a function that calculates the factorial of a number with input validation. You can test it in the new cell provided.', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, tzinfo=datetime.timezone.utc), kind='response'),
  ModelRequest(parts=[UserPromptPart(content='So what you just made for me here?', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, 46240, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
  ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. The function includes input validation to ensure that the input is a non-negative integer. If the input is not an integer or is negative, the function raises a `ValueError` with an appropriate message. \n\nHere's a summary of the key parts of the code:\n\n- **Input Validation**: \n  - Checks if `n` is an integer. If not, it raises a `ValueError`.\n  - Checks if `n` is a non-negative integer. If `n` is negative, it raises a `ValueError`.\n\n- **Factorial Calculation**: \n  - Uses an iterative approach to calculate the factorial.\n  - Returns `1` if `n` is `0` (the factorial of 0 is 1).\n  - Uses a for-loop to compute the factorial for positive integers.\n\n- **Example Usage**: \n  - Demonstrates the function by calculating the factorial of 5.\n  - Includes a try-except block to catch and print the error message if a `ValueError` is raised when computing the factorial of a negative number.\n\nYou can execute the cell to see how it works or modify it to test with other values.", part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, tzinfo=datetime.timezone.utc), kind='response'),
  ModelRequest(parts=[UserPromptPart(content='Here is the context of new notebook cells that were added:\nCell[11]:\nSource:\n#| export\nfrom IPython.display import display, Markdown\nfrom typing import Literal\n\n@notebook_agent.tool\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\'code\', \'markdown\'] = \'code\') -&gt; str:\n    """Create a new cell in the notebook with the specified content.\n    \n    Args:\n        content: The content to put in the new cell\n        cell_type: Type of cell to create (\'code\' or \'markdown\')\n    \n    Returns:\n        A confirmation message\n    """\n    try:    \n        ipython = get_ipython()\n    except NameError:\n        return "Error: Not running in IPython/Jupyter environment"\n    \n    # Display the content immediately\n    if cell_type == \'code\':\n        # Set up the next cell with the content\n        ipython.set_next_input(content)\n    else:\n        display(Markdown(content))\n    \n    return f"Created new {cell_type}  with content: {content}"\nOutputs:\n[{\'name\': \'stderr\', \'output_type\': \'stream\', \'text\': [\'&lt;module&gt;:8: No type or annotation for returned value 1\\n\']}]\n\nCell[12]:\nSource:\nAlways set custom agents to inherit base tools\n\nOutputs:\nNone\n\nCell[13]:\nSource:\n#| export\ndef set_agent(agent: Agent) -&gt; Agent:\n    """Set a custom agent for the notebook.\n    \n    Args:\n        agent: PydanticAI agent instance\n        \n    Returns:\n        Configured agent with required tools\n    """\n    global _current_agent, notebook_agent\n        \n    # Always ensure create_cell tool is available\n    if \'create_cell\' not in agent._function_tools:\n        # Copy the tool directly from notebook_agent\n        agent._function_tools = notebook_agent._function_tools\n    \n    _current_agent = agent\n    return agent\nOutputs:\n[]\n\nCell[14]:\nSource:\nTool testing cell creation tool\nOutputs:\nNone\n\nCell[15]:\nSource:\nresult = notebook_agent.run_sync(\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\')\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I\\\'ve created a new cell with a simple "Hello, World!" function. You can run it to see the output.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 10, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[16]:\nSource:\ndef hello_world():\n    print("Hello, world!")\n\nhello_world()\nOutputs:\n[]\n\nCell[17]:\nSource:\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 12, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[18]:\nSource:\ndef factorial(n):\n    """\n    Calculate the factorial of a non-negative integer n.\n\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed\n\n    Returns:\n    int: Factorial of the input number n\n    """\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError("Input must be an integer")\n    if n &lt; 0:\n        raise ValueError("Input must be a non-negative integer")\n\n    # Base case: factorial of 0 is 1\n    if n == 0:\n        return 1\n\n    # Recursive case: n! = n * (n-1)!\n    return n * factorial(n - 1)\nOutputs:\n[]\n\nCell[19]:\nSource:\nTesting agent with history\nOutputs:\nNone\n\nCell[20]:\nSource:\nresult = notebook_agent.run_sync(\'So what you just made for me here?\', message_history=result.new_messages())\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\n\', \'\\n\', "Here\'s a summary of what the function does:\\n", \'- It checks if the input is an integer. If not, it raises a `ValueError`.\\n\', "- It checks if the input is a non-negative integer. If it\'s negative, it raises a `ValueError`.\\n", \'- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\n\', \'- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 14, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[21]:\nSource:\nresult.all_messages()\nOutputs:\n[{\'data\': {\'text/plain\': [\'[ModelRequest(parts=[SystemPromptPart(content="\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\'s date is 2024-12-31.\\\\n", part_kind=\\\'system-prompt\\\'), UserPromptPart(content=\\\'Create a function that calculates the factorial of a number with input validation\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 28, 691513, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', \' ModelResponse(parts=[ToolCallPart(tool_name=\\\'create_cell\\\', args=ArgsJson(args_json=\\\'{"content":"def factorial(n):\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\\\\\n    :param n: non-negative integer\\\\\\\\n    :return: factorial of n\\\\\\\\n    :raises ValueError: if n is not a non-negative integer\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    if not isinstance(n, int):\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be an integer\\\\\\\\")\\\\\\\\n    if n &lt; 0:\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be a non-negative integer\\\\\\\\")\\\\\\\\n    if n == 0 or n == 1:\\\\\\\\n        return 1\\\\\\\\n    result = 1\\\\\\\\n    for i in range(2, n + 1):\\\\\\\\n        result *= i\\\\\\\\n    return result","cell_type":"code"}\\\'), tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', part_kind=\\\'tool-call\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 29, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[ToolReturnPart(tool_name=\\\'create_cell\\\', content=\\\'Created new code  with content: def factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\n    :param n: non-negative integer\\\\n    :return: factorial of n\\\\n    :raises ValueError: if n is not a non-negative integer\\\\n    """\\\\n    if not isinstance(n, int):\\\\n        raise ValueError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n    if n == 0 or n == 1:\\\\n        return 1\\\\n    result = 1\\\\n    for i in range(2, n + 1):\\\\n        result *= i\\\\n    return result\\\', tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 32, 646314, tzinfo=datetime.timezone.utc), part_kind=\\\'tool-return\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what you just made for me here?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, 948002, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\\\n\\\\nHere\\\'s a summary of what the function does:\\\\n- It checks if the input is an integer. If not, it raises a `ValueError`.\\\\n- It checks if the input is a non-negative integer. If it\\\'s negative, it raises a `ValueError`.\\\\n- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\\\n- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.", part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 34, tzinfo=datetime.timezone.utc), kind=\\\'response\\\')]\']}, \'execution_count\': 15, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[22]:\nSource:\n\nOutputs:\nNone\n\nCell[23]:\nSource:\n### Adding notebook history\nOutputs:\nNone\n\nCell[24]:\nSource:\n#| export\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\n\n# Cache for notebook data\n_notebook_cache: Dict[str, Any] = {}\n\ndef find_current_notebook() -&gt; Optional[dict]:\n    """Find and cache the current notebook data.\n    \n    Returns:\n        Dict containing notebook data or None if not found\n    """\n    global _notebook_cache\n    \n    try:\n        ipython = get_ipython()\n        if not ipython:\n            return None\n            \n        # Get current cell content to identify the notebook\n        current_cell = ipython.get_parent()[\'content\'][\'code\']\n        \n        # Check if we already found the notebook\n        if \'notebook\' in _notebook_cache:\n            # Verify it\'s still the correct notebook by checking the current cell\n            notebook = _notebook_cache[\'notebook\']\n            for cell in notebook[\'cells\']:\n                if (cell[\'cell_type\'] == \'code\' and \n                    \'\'.join(cell[\'source\']) == current_cell):\n                    return notebook\n        \n        # If not in cache or cache is invalid, search for the notebook\n        current_dir = Path.cwd()\n        notebook_files = list(current_dir.glob("*.ipynb"))\n        \n        for nb_file in notebook_files:\n            try:\n                with open(nb_file) as f:\n                    notebook = json.load(f)\n                    for cell in notebook[\'cells\']:\n                        if (cell[\'cell_type\'] == \'code\' and \n                            \'\'.join(cell[\'source\']) == current_cell):\n                            # Found the notebook, cache it\n                            _notebook_cache[\'notebook\'] = notebook\n                            _notebook_cache[\'file\'] = nb_file\n                            return notebook\n            except Exception:\n                continue\n                \n        return None\n        \n    except Exception as e:\n        print(f"Error finding notebook: {e}")\n        return None\n\nOutputs:\n[]\n\nCell[25]:\nSource:\n#| export\nmax_lookback = 10\n\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\n    """Get the content of notebook cells between current and last prompt cell.\n    \n    Args:\n        max_cells: Maximum number of previous cells to include\n        \n    Returns:\n        List of previous cell contents\n    """\n    try:\n        # Get the cached notebook or find it\n        notebook = find_current_notebook()\n        if not notebook:\n            return []\n            \n        # Find current cell index\n        current_cell = get_ipython().get_parent()[\'content\'][\'code\']\n        cells = notebook[\'cells\']\n        current_idx = -1\n        last_prompt_idx = -1\n        \n        # Find current cell and last prompt cell\n        for idx, cell in enumerate(cells):\n            source = \'\'.join(cell[\'source\']) if isinstance(cell[\'source\'], list) else cell[\'source\']\n            \n            # Find current cell\n            if current_idx == -1 and cell[\'cell_type\'] == \'code\' and source == current_cell:\n                current_idx = idx\n                \n            # Find last prompt cell before current cell\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\n                if cell[\'cell_type\'] == \'code\' and source.strip().startswith(\'%%prompt\'):\n                    last_prompt_idx = idx\n                \n        if current_idx == -1:\n            return []\n            \n        # Get cells between last prompt and current cell\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\n        history = []\n        \n        for idx in range(start_idx, current_idx):\n            cell = cells[idx]            \n            source = cell[\'source\'] if isinstance(cell[\'source\'], str) else \'\'.join(cell[\'source\'])\n            if \'outputs\' in cell:\n                outputs = cell[\'outputs\'] if isinstance(cell[\'outputs\'], str) else str(cell[\'outputs\'])\n            else:\n                outputs = \'None\'\n            if not (source.strip().startswith(\'%%prompt\') or outputs.strip().startswith(\'#|exclude\') or outputs.strip().startswith(\'#| exclude\')):\n                history.append(f"Cell[{idx}]:\\nSource:\\n{source}\\nOutputs:\\n{outputs}")\n        \n        return history\n        \n    except Exception as e:\n        print(f"Error getting notebook history: {e}")\n        return []\nOutputs:\n[]\n\nCell[26]:\nSource:\nTesting notebook history\nOutputs:\nNone\n\nCell[27]:\nSource:\nnb_hist = get_notebook_history(max_cells=20)\nnb_hist\nOutputs:\n[{\'data\': {\'text/plain\': ["[\'Cell[5]:\\\\nSource:\\\\nSystem prompt\\\\n\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[6]:\\\\nSource:\\\\n#| export\\\\nfrom datetime import date\\\\nsystem_prompt = f"""\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\\\\\'s date is {date.today().strftime(\\\\\\\'%Y-%m-%d\\\\\\\')}.\\\\n"""\\\\nOutputs:\\\\n[]\\\',\\n\', \' "Cell[7]:\\\\nSource:\\\\n#| export\\\\nfrom typing import cast\\\\nmodel = cast(KnownModelName, os.getenv(\\\'PYDANTIC_AI_MODEL\\\', \\\'openai:gpt-4o\\\'))\\\\nprint(f\\\'PydanticAI is using model: {model}\\\')\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\nOutputs:\\\\n[{\\\'name\\\': \\\'stdout\\\', \\\'output_type\\\': \\\'stream\\\', \\\'text\\\': [\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\n\\\']}]",\\n\', \' \\\'Cell[8]:\\\\nSource:\\\\n#| export\\\\n_current_agent: Optional[Agent] = None\\\\n\\\\ndef get_current_agent() -&gt; Agent:\\\\n    """Get the current agent, falling back to default notebook_agent if none set."""\\\\n    global _current_agent, notebook_agent\\\\n    return _current_agent or notebook_agent\\\\n\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[9]:\\\\nSource:\\\\n### Adding cell creation tool\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[10]:\\\\nSource:\\\\n#| export\\\\nfrom IPython.display import display, Markdown\\\\nfrom typing import Literal\\\\n\\\\n@notebook_agent.tool\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\'code\\\\\\\', \\\\\\\'markdown\\\\\\\'] = \\\\\\\'code\\\\\\\') -&gt; str:\\\\n    """Create a new cell in the notebook with the specified content.\\\\n    \\\\n    Args:\\\\n        content: The content to put in the new cell\\\\n        cell_type: Type of cell to create (\\\\\\\'code\\\\\\\' or \\\\\\\'markdown\\\\\\\')\\\\n    \\\\n    Returns:\\\\n        A confirmation message\\\\n    """\\\\n    try:    \\\\n        ipython = get_ipython()\\\\n    except NameError:\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\n    \\\\n    # Display the content immediately\\\\n    if cell_type == \\\\\\\'code\\\\\\\':\\\\n        # Set up the next cell with the content\\\\n        ipython.set_next_input(content)\\\\n    else:\\\\n        display(Markdown(content))\\\\n    \\\\n    return f"Created new {cell_type}  with content: {content}"\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[11]:\\\\nSource:\\\\nAlways set custom agents to have create_cell tool\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[12]:\\\\nSource:\\\\n#| export\\\\ndef set_agent(agent: Agent) -&gt; Agent:\\\\n    """Set a custom agent for the notebook.\\\\n    \\\\n    Args:\\\\n        agent: PydanticAI agent instance\\\\n        \\\\n    Returns:\\\\n        Configured agent with required tools\\\\n    """\\\\n    global _current_agent, notebook_agent\\\\n        \\\\n    # Always ensure create_cell tool is available\\\\n    if \\\\\\\'create_cell\\\\\\\' not in agent._function_tools:\\\\n        # Copy the tool directly from notebook_agent\\\\n        agent._function_tools[\\\\\\\'create_cell\\\\\\\'] = notebook_agent._function_tools[\\\\\\\'create_cell\\\\\\\']\\\\n    \\\\n    _current_agent = agent\\\\n    return agent\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[13]:\\\\nSource:\\\\nTool testing\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[14]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\')\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': [\\\\\\\'I\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 7, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\',\\n\', \' "Cell[15]:\\\\nSource:\\\\ndef hello_world():\\\\n    print(\\\'Hello, World!\\\')\\\\n\\\\n# Call the function to display the output\\\\nhello_world()\\\\nOutputs:\\\\n[{\\\'name\\\': \\\'stdout\\\', \\\'output_type\\\': \\\'stream\\\', \\\'text\\\': [\\\'Hello, World!\\\\\\\\n\\\']}]",\\n\', \' \\\'Cell[16]:\\\\nSource:\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\'s environment."], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 9, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\',\\n\', \' \\\'Cell[17]:\\\\nSource:\\\\ndef factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n.\\\\n\\\\n    Parameters:\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\n\\\\n    Returns:\\\\n    int: Factorial of the input number n\\\\n    """\\\\n    # Input validation\\\\n    if not isinstance(n, int):\\\\n        raise TypeError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n\\\\n    # Base case: factorial of 0 is 1\\\\n    if n == 0:\\\\n        return 1\\\\n\\\\n    # Recursive case: n! = n * (n-1)!\\\\n    return n * factorial(n - 1)\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[18]:\\\\nSource:\\\\nTesting agent with history\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[19]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'So what you just made for me here?\\\\\\\', message_history=result.new_messages())\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\'s a brief overview of its features:\\\\\\\\n", \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\n\\\\\\\', \\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\).\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'```python\\\\\\\\n\\\\\\\', \\\\\\\'factorial(5)\\\\\\\\n\\\\\\\', \\\\\\\'```\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 11, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\',\\n\', \' \\\'Cell[20]:\\\\nSource:\\\\nresult.all_messages()\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': [\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\')]\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 12, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\',\\n\', " \'Cell[21]:\\\\nSource:\\\\n### Adding notebook history\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[22]:\\\\nSource:\\\\n#| export\\\\nimport os\\\\nimport json\\\\nfrom pathlib import Path\\\\nfrom typing import Optional, Dict, Any\\\\n\\\\n# Cache for notebook data\\\\n_notebook_cache: Dict[str, Any] = {}\\\\n\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\n    """Find and cache the current notebook data.\\\\n    \\\\n    Returns:\\\\n        Dict containing notebook data or None if not found\\\\n    """\\\\n    global _notebook_cache\\\\n    \\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return None\\\\n            \\\\n        # Get current cell content to identify the notebook\\\\n        current_cell = ipython.get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        \\\\n        # Check if we already found the notebook\\\\n        if \\\\\\\'notebook\\\\\\\' in _notebook_cache:\\\\n            # Verify it\\\\\\\'s still the correct notebook by checking the current cell\\\\n            notebook = _notebook_cache[\\\\\\\'notebook\\\\\\\']\\\\n            for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                    \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                    return notebook\\\\n        \\\\n        # If not in cache or cache is invalid, search for the notebook\\\\n        current_dir = Path.cwd()\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\n        \\\\n        for nb_file in notebook_files:\\\\n            try:\\\\n                with open(nb_file) as f:\\\\n                    notebook = json.load(f)\\\\n                    for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                        if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                            \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                            # Found the notebook, cache it\\\\n                            _notebook_cache[\\\\\\\'notebook\\\\\\\'] = notebook\\\\n                            _notebook_cache[\\\\\\\'file\\\\\\\'] = nb_file\\\\n                            return notebook\\\\n            except Exception:\\\\n                continue\\\\n                \\\\n        return None\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error finding notebook: {e}")\\\\n        return None\\\\n\\\\nOutputs:\\\\n[]\\\',\\n\', \' \\\'Cell[23]:\\\\nSource:\\\\n#| export\\\\nmax_lookback = 10\\\\n\\\\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\n    \\\\n    Args:\\\\n        max_cells: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        List of previous cell contents\\\\n    """\\\\n    try:\\\\n        # Get the cached notebook or find it\\\\n        notebook = find_current_notebook()\\\\n        if not notebook:\\\\n            return []\\\\n            \\\\n        # Find current cell index\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        cells = notebook[\\\\\\\'cells\\\\\\\']\\\\n        current_idx = -1\\\\n        last_prompt_idx = -1\\\\n        \\\\n        # Find current cell and last prompt cell\\\\n        for idx, cell in enumerate(cells):\\\\n            source = \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) if isinstance(cell[\\\\\\\'source\\\\\\\'], list) else cell[\\\\\\\'source\\\\\\\']\\\\n            \\\\n            # Find current cell\\\\n            if current_idx == -1 and cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source == current_cell:\\\\n                current_idx = idx\\\\n                \\\\n            # Find last prompt cell before current cell\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\n                if cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source.strip().startswith(\\\\\\\'%%prompt\\\\\\\'):\\\\n                    last_prompt_idx = idx\\\\n                \\\\n        if current_idx == -1:\\\\n            return []\\\\n            \\\\n        # Get cells between last prompt and current cell\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\n        history = []\\\\n        \\\\n        for idx in range(start_idx, current_idx):\\\\n            cell = cells[idx]            \\\\n            source = cell[\\\\\\\'source\\\\\\\'] if isinstance(cell[\\\\\\\'source\\\\\\\'], str) else \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\'])\\\\n            if \\\\\\\'outputs\\\\\\\' in cell:\\\\n                outputs = cell[\\\\\\\'outputs\\\\\\\'] if isinstance(cell[\\\\\\\'outputs\\\\\\\'], str) else str(cell[\\\\\\\'outputs\\\\\\\'])\\\\n            else:\\\\n                outputs = \\\\\\\'None\\\\\\\'\\\\n            if not (source.strip().startswith(\\\\\\\'%%prompt\\\\\\\') or outputs.strip().startswith(\\\\\\\'#|exclude\\\\\\\') or outputs.strip().startswith(\\\\\\\'#| exclude\\\\\\\')):\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\nSource:\\\\\\\\n{source}\\\\\\\\nOutputs:\\\\\\\\n{outputs}")\\\\n        \\\\n        return history\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error getting notebook history: {e}")\\\\n        return []\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[24]:\\\\nSource:\\\\nTesting notebook history\\\\nOutputs:\\\\nNone\']"]}, \'execution_count\': 18, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[28]:\nSource:\n### Creating history-aware prompt\nOutputs:\nNone\n\nCell[29]:\nSource:\n#| export\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\n    """Create a prompt with notebook history context and message history.\n    \n    Args:\n        prompt: The user\'s prompt\n        message_history: Previous conversation messages from results.all_messages()\n        max_history: Maximum number of previous cells to include\n        \n    Returns:\n        Tuple of (enhanced prompt, combined message history)\n    """\n    try:\n        ipython = get_ipython()\n        if not ipython:\n            return prompt, message_history\n        \n        # Get new cells using our optimized get_notebook_history\n        new_cells = get_notebook_history(max_cells=max_history)\n        \n        if not new_cells and not message_history:\n            return prompt, None\n            \n        # Create message history if none exists\n        from pydantic_ai.messages import (\n            ModelRequest, ModelResponse, \n            UserPromptPart, TextPart\n        )\n        \n        messages = []\n        \n        # Add existing message history if provided\n        if message_history:\n            messages.extend(message_history)\n        \n        # Only add context message if we have new cells\n        if new_cells:\n            # Create context message with new cells\n            history_content = "\\n\\n".join(new_cells)\n\n            context_msg = ModelRequest(parts=[\n                UserPromptPart(\n                    content="Here is the context of new notebook cells that were added:\\n" + history_content\n                )\n            ])\n            \n            # Create response acknowledging new context\n            context_response = ModelResponse(parts=[\n                TextPart(\n                    content="I understand the new notebook context. How can I help?"\n                )\n            ])\n            \n            messages.extend([context_msg, context_response])\n                \n        return prompt, messages\n        \n    except Exception as e:\n        print(f"Error creating history-aware prompt: {e}")\n        return prompt, message_history\nOutputs:\n[]\n\nCell[30]:\nSource:\nTesting history-aware prompt\nOutputs:\nNone', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 52, 367833, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
  ModelResponse(parts=[TextPart(content='I understand the new notebook context. How can I help?', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 52, 367852, tzinfo=datetime.timezone.utc), kind='response')])</code></pre>
</div>
</div>
</section>
<section id="running-agent-with-notebook-history" class="level3">
<h3 class="anchored" data-anchor-id="running-agent-with-notebook-history">Running agent with notebook history</h3>
<hr>
<p><a href="https://github.com/ndendic/jupy-juice/blob/main/jupy_juice/core.py#L278" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="run_with_history" class="level3">
<h3 class="anchored" data-anchor-id="run_with_history">run_with_history</h3>
<blockquote class="blockquote">
<pre><code> run_with_history (agent:pydantic_ai.agent.Agent, prompt:str,
                   message_history:list=None, max_history:int=5)</code></pre>
</blockquote>
<p>*Run the agent with notebook and conversation history context.</p>
<p>Args: agent: The PydanticAI agent prompt: The user‚Äôs prompt message_history: Previous conversation messages max_history: Maximum number of previous cells to include</p>
<p>Returns: Agent run result*</p>
<p>Testing run_with_history</p>
<div id="cell-30" class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> run_with_history(notebook_agent, <span class="st">'So what is going on in this notebook?'</span>,result.all_messages(), max_history<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>Markdown(result.data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display cell-output-markdown">
<p>This notebook appears to involve creating, running, and testing an AI-powered assistant, possibly using a tool like Pydantic AI for Jupyter notebooks. Here‚Äôs a breakdown of the key components and activities happening in this notebook:</p>
<ol type="1">
<li><strong>Setup and Imports</strong>:
<ul>
<li>The notebook is set up with various imports from libraries and definitions of system prompts to prepare the AI agent to assist within a Jupyter environment.</li>
</ul></li>
<li><strong>Agent Configuration</strong>:
<ul>
<li>An AI agent (likely PydanticAI or a similar framework) is configured with a model and system prompts to guide its behavior within the notebook.</li>
</ul></li>
<li><strong>Tool and Function Definitions</strong>:
<ul>
<li>Several functions and tools are defined, including <a href="https://ndendic.github.io/jupy-juice/core.html#create_cell"><code>create_cell</code></a>, which allows new cells to be programmatically added to the notebook.</li>
</ul></li>
<li><strong>Notebook Agent Execution</strong>:
<ul>
<li>The AI agent is used to execute commands. Examples include requests to create a ‚ÄúHello, World!‚Äù function and a factorial function with input validation.</li>
</ul></li>
<li><strong>Function Implementation</strong>:
<ul>
<li>Functions like <code>hello_world()</code> and <code>factorial()</code> are defined as part of this process. The <code>factorial</code> function includes input validation and uses recursion to calculate factorials.</li>
</ul></li>
<li><strong>Notebook History and Prompt Management</strong>:
<ul>
<li>There are methods for capturing the history of cell executions and creating context-aware prompts that consider both the current notebook state and any previous interactions or commands.</li>
</ul></li>
<li><strong>Execution Testing</strong>:
<ul>
<li>Various cells are used to test the system, ensure that functionality is operating correctly, and demonstrate the capabilities of the conversational agent in a Jupyter context.</li>
</ul></li>
<li><strong>Error Handling and Validation</strong>:
<ul>
<li>The notebook handles potential errors (e.g., invalid inputs for the factorial function) and various elements of cell execution and output display.</li>
</ul></li>
<li><strong>History Creation and Contextual Responses</strong>:
<ul>
<li>An advanced feature is the creation of context-aware prompts that adapt based on the content and history of the notebook, indicating a sophisticated interaction system between user inputs and the agent‚Äôs responses.</li>
</ul></li>
</ol>
<p>In summary, the notebook combines Jupyter‚Äôs interactive capabilities with an AI-driven agent to assist with tasks, automatically manage notebook content, and potentially perform more complex logical operations based on the commands or tasks provided by the user.</p>
</div>
</div>
<div id="cell-31" class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>result.all_messages()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>[ModelRequest(parts=[SystemPromptPart(content="\nYou are a helpful assistant that operates in a Jupyter notebook.\nYour regular text responses are rendered as cell output.\nYou can create new cells, edit existing cells, and run code.\nYou can also use tools to help you with your tasks.\nToday's date is 2024-12-31.\n", part_kind='system-prompt'), UserPromptPart(content='Create a function that calculates the factorial of a number with input validation', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 43, 700768, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[ToolCallPart(tool_name='create_cell', args=ArgsJson(args_json='{"content":"def factorial(n):\\n    \\"\\"\\"\\n    Calculate the factorial of a non-negative integer n.\\n    \\n    :param n: non-negative integer\\n    :return: factorial of n\\n    \\"\\"\\"\\n    # Input validation\\n    if not isinstance(n, int):\\n        raise ValueError(\\"Input must be an integer.\\")\\n    if n &lt; 0:\\n        raise ValueError(\\"Input must be a non-negative integer.\\")\\n    \\n    # Base case\\n    if n == 0:\\n        return 1\\n    \\n    # Recursive case\\n    result = 1\\n    for i in range(1, n + 1):\\n        result *= i\\n    return result\\n\\n# Example usage\\ntry:\\n    print(factorial(5))  # Should print 120\\n    print(factorial(-1)) # Should raise a ValueError\\nexcept ValueError as e:\\n    print(e)","cell_type":"code"}'), tool_call_id='call_dP852a9HSFo4HgyvUTm6NtHd', part_kind='tool-call')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 44, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[ToolReturnPart(tool_name='create_cell', content='Created new code  with content: def factorial(n):\n    """\n    Calculate the factorial of a non-negative integer n.\n    \n    :param n: non-negative integer\n    :return: factorial of n\n    """\n    # Input validation\n    if not isinstance(n, int):\n        raise ValueError("Input must be an integer.")\n    if n &lt; 0:\n        raise ValueError("Input must be a non-negative integer.")\n    \n    # Base case\n    if n == 0:\n        return 1\n    \n    # Recursive case\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n# Example usage\ntry:\n    print(factorial(5))  # Should print 120\n    print(factorial(-1)) # Should raise a ValueError\nexcept ValueError as e:\n    print(e)', tool_call_id='call_dP852a9HSFo4HgyvUTm6NtHd', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 47, 279330, tzinfo=datetime.timezone.utc), part_kind='tool-return')], kind='request'),
 ModelResponse(parts=[TextPart(content='I created a function that calculates the factorial of a number with input validation. You can test it in the new cell provided.', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[UserPromptPart(content='So what you just made for me here?', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, 46240, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. The function includes input validation to ensure that the input is a non-negative integer. If the input is not an integer or is negative, the function raises a `ValueError` with an appropriate message. \n\nHere's a summary of the key parts of the code:\n\n- **Input Validation**: \n  - Checks if `n` is an integer. If not, it raises a `ValueError`.\n  - Checks if `n` is a non-negative integer. If `n` is negative, it raises a `ValueError`.\n\n- **Factorial Calculation**: \n  - Uses an iterative approach to calculate the factorial.\n  - Returns `1` if `n` is `0` (the factorial of 0 is 1).\n  - Uses a for-loop to compute the factorial for positive integers.\n\n- **Example Usage**: \n  - Demonstrates the function by calculating the factorial of 5.\n  - Includes a try-except block to catch and print the error message if a `ValueError` is raised when computing the factorial of a negative number.\n\nYou can execute the cell to see how it works or modify it to test with other values.", part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 48, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[UserPromptPart(content='Here is the context of new notebook cells that were added:\nCell[15]:\nSource:\nresult = notebook_agent.run_sync(\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\')\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I\\\'ve created a new cell with a simple "Hello, World!" function. You can run it to see the output.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 10, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[16]:\nSource:\ndef hello_world():\n    print("Hello, world!")\n\nhello_world()\nOutputs:\n[]\n\nCell[17]:\nSource:\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 12, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[18]:\nSource:\ndef factorial(n):\n    """\n    Calculate the factorial of a non-negative integer n.\n\n    Parameters:\n    n (int): A non-negative integer whose factorial is to be computed\n\n    Returns:\n    int: Factorial of the input number n\n    """\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError("Input must be an integer")\n    if n &lt; 0:\n        raise ValueError("Input must be a non-negative integer")\n\n    # Base case: factorial of 0 is 1\n    if n == 0:\n        return 1\n\n    # Recursive case: n! = n * (n-1)!\n    return n * factorial(n - 1)\nOutputs:\n[]\n\nCell[19]:\nSource:\nTesting agent with history\nOutputs:\nNone\n\nCell[20]:\nSource:\nresult = notebook_agent.run_sync(\'So what you just made for me here?\', message_history=result.new_messages())\nMarkdown(result.data)\nOutputs:\n[{\'data\': {\'text/markdown\': [\'I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\n\', \'\\n\', "Here\'s a summary of what the function does:\\n", \'- It checks if the input is an integer. If not, it raises a `ValueError`.\\n\', "- It checks if the input is a non-negative integer. If it\'s negative, it raises a `ValueError`.\\n", \'- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\n\', \'- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.\'], \'text/plain\': [\'&lt;IPython.core.display.Markdown object&gt;\']}, \'execution_count\': 14, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[21]:\nSource:\nresult.all_messages()\nOutputs:\n[{\'data\': {\'text/plain\': [\'[ModelRequest(parts=[SystemPromptPart(content="\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\'s date is 2024-12-31.\\\\n", part_kind=\\\'system-prompt\\\'), UserPromptPart(content=\\\'Create a function that calculates the factorial of a number with input validation\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 28, 691513, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', \' ModelResponse(parts=[ToolCallPart(tool_name=\\\'create_cell\\\', args=ArgsJson(args_json=\\\'{"content":"def factorial(n):\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\\\\\n    :param n: non-negative integer\\\\\\\\n    :return: factorial of n\\\\\\\\n    :raises ValueError: if n is not a non-negative integer\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    if not isinstance(n, int):\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be an integer\\\\\\\\")\\\\\\\\n    if n &lt; 0:\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be a non-negative integer\\\\\\\\")\\\\\\\\n    if n == 0 or n == 1:\\\\\\\\n        return 1\\\\\\\\n    result = 1\\\\\\\\n    for i in range(2, n + 1):\\\\\\\\n        result *= i\\\\\\\\n    return result","cell_type":"code"}\\\'), tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', part_kind=\\\'tool-call\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 29, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[ToolReturnPart(tool_name=\\\'create_cell\\\', content=\\\'Created new code  with content: def factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\n    :param n: non-negative integer\\\\n    :return: factorial of n\\\\n    :raises ValueError: if n is not a non-negative integer\\\\n    """\\\\n    if not isinstance(n, int):\\\\n        raise ValueError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n    if n == 0 or n == 1:\\\\n        return 1\\\\n    result = 1\\\\n    for i in range(2, n + 1):\\\\n        result *= i\\\\n    return result\\\', tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 32, 646314, tzinfo=datetime.timezone.utc), part_kind=\\\'tool-return\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what you just made for me here?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, 948002, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\\\n\\\\nHere\\\'s a summary of what the function does:\\\\n- It checks if the input is an integer. If not, it raises a `ValueError`.\\\\n- It checks if the input is a non-negative integer. If it\\\'s negative, it raises a `ValueError`.\\\\n- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\\\n- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.", part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 34, tzinfo=datetime.timezone.utc), kind=\\\'response\\\')]\']}, \'execution_count\': 15, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[22]:\nSource:\n\nOutputs:\nNone\n\nCell[23]:\nSource:\n### Adding notebook history\nOutputs:\nNone\n\nCell[24]:\nSource:\n#| export\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\n\n# Cache for notebook data\n_notebook_cache: Dict[str, Any] = {}\n\ndef find_current_notebook() -&gt; Optional[dict]:\n    """Find and cache the current notebook data.\n    \n    Returns:\n        Dict containing notebook data or None if not found\n    """\n    global _notebook_cache\n    \n    try:\n        ipython = get_ipython()\n        if not ipython:\n            return None\n            \n        # Get current cell content to identify the notebook\n        current_cell = ipython.get_parent()[\'content\'][\'code\']\n        \n        # Check if we already found the notebook\n        if \'notebook\' in _notebook_cache:\n            # Verify it\'s still the correct notebook by checking the current cell\n            notebook = _notebook_cache[\'notebook\']\n            for cell in notebook[\'cells\']:\n                if (cell[\'cell_type\'] == \'code\' and \n                    \'\'.join(cell[\'source\']) == current_cell):\n                    return notebook\n        \n        # If not in cache or cache is invalid, search for the notebook\n        current_dir = Path.cwd()\n        notebook_files = list(current_dir.glob("*.ipynb"))\n        \n        for nb_file in notebook_files:\n            try:\n                with open(nb_file) as f:\n                    notebook = json.load(f)\n                    for cell in notebook[\'cells\']:\n                        if (cell[\'cell_type\'] == \'code\' and \n                            \'\'.join(cell[\'source\']) == current_cell):\n                            # Found the notebook, cache it\n                            _notebook_cache[\'notebook\'] = notebook\n                            _notebook_cache[\'file\'] = nb_file\n                            return notebook\n            except Exception:\n                continue\n                \n        return None\n        \n    except Exception as e:\n        print(f"Error finding notebook: {e}")\n        return None\n\nOutputs:\n[]\n\nCell[25]:\nSource:\n#| export\nmax_lookback = 10\n\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\n    """Get the content of notebook cells between current and last prompt cell.\n    \n    Args:\n        max_cells: Maximum number of previous cells to include\n        \n    Returns:\n        List of previous cell contents\n    """\n    try:\n        # Get the cached notebook or find it\n        notebook = find_current_notebook()\n        if not notebook:\n            return []\n            \n        # Find current cell index\n        current_cell = get_ipython().get_parent()[\'content\'][\'code\']\n        cells = notebook[\'cells\']\n        current_idx = -1\n        last_prompt_idx = -1\n        \n        # Find current cell and last prompt cell\n        for idx, cell in enumerate(cells):\n            source = \'\'.join(cell[\'source\']) if isinstance(cell[\'source\'], list) else cell[\'source\']\n            \n            # Find current cell\n            if current_idx == -1 and cell[\'cell_type\'] == \'code\' and source == current_cell:\n                current_idx = idx\n                \n            # Find last prompt cell before current cell\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\n                if cell[\'cell_type\'] == \'code\' and source.strip().startswith(\'%%prompt\'):\n                    last_prompt_idx = idx\n                \n        if current_idx == -1:\n            return []\n            \n        # Get cells between last prompt and current cell\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\n        history = []\n        \n        for idx in range(start_idx, current_idx):\n            cell = cells[idx]            \n            source = cell[\'source\'] if isinstance(cell[\'source\'], str) else \'\'.join(cell[\'source\'])\n            if \'outputs\' in cell:\n                outputs = cell[\'outputs\'] if isinstance(cell[\'outputs\'], str) else str(cell[\'outputs\'])\n            else:\n                outputs = \'None\'\n            if not (source.strip().startswith(\'%%prompt\') or outputs.strip().startswith(\'#|exclude\') or outputs.strip().startswith(\'#| exclude\')):\n                history.append(f"Cell[{idx}]:\\nSource:\\n{source}\\nOutputs:\\n{outputs}")\n        \n        return history\n        \n    except Exception as e:\n        print(f"Error getting notebook history: {e}")\n        return []\nOutputs:\n[]\n\nCell[26]:\nSource:\nTesting notebook history\nOutputs:\nNone\n\nCell[27]:\nSource:\nnb_hist = get_notebook_history(max_cells=20)\nnb_hist\nOutputs:\n[{\'data\': {\'text/plain\': ["[\'Cell[5]:\\\\nSource:\\\\nSystem prompt\\\\n\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[6]:\\\\nSource:\\\\n#| export\\\\nfrom datetime import date\\\\nsystem_prompt = f"""\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\\\\\'s date is {date.today().strftime(\\\\\\\'%Y-%m-%d\\\\\\\')}.\\\\n"""\\\\nOutputs:\\\\n[]\\\',\\n\', \' "Cell[7]:\\\\nSource:\\\\n#| export\\\\nfrom typing import cast\\\\nmodel = cast(KnownModelName, os.getenv(\\\'PYDANTIC_AI_MODEL\\\', \\\'openai:gpt-4o\\\'))\\\\nprint(f\\\'PydanticAI is using model: {model}\\\')\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\nOutputs:\\\\n[{\\\'name\\\': \\\'stdout\\\', \\\'output_type\\\': \\\'stream\\\', \\\'text\\\': [\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\n\\\']}]",\\n\', \' \\\'Cell[8]:\\\\nSource:\\\\n#| export\\\\n_current_agent: Optional[Agent] = None\\\\n\\\\ndef get_current_agent() -&gt; Agent:\\\\n    """Get the current agent, falling back to default notebook_agent if none set."""\\\\n    global _current_agent, notebook_agent\\\\n    return _current_agent or notebook_agent\\\\n\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[9]:\\\\nSource:\\\\n### Adding cell creation tool\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[10]:\\\\nSource:\\\\n#| export\\\\nfrom IPython.display import display, Markdown\\\\nfrom typing import Literal\\\\n\\\\n@notebook_agent.tool\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\'code\\\\\\\', \\\\\\\'markdown\\\\\\\'] = \\\\\\\'code\\\\\\\') -&gt; str:\\\\n    """Create a new cell in the notebook with the specified content.\\\\n    \\\\n    Args:\\\\n        content: The content to put in the new cell\\\\n        cell_type: Type of cell to create (\\\\\\\'code\\\\\\\' or \\\\\\\'markdown\\\\\\\')\\\\n    \\\\n    Returns:\\\\n        A confirmation message\\\\n    """\\\\n    try:    \\\\n        ipython = get_ipython()\\\\n    except NameError:\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\n    \\\\n    # Display the content immediately\\\\n    if cell_type == \\\\\\\'code\\\\\\\':\\\\n        # Set up the next cell with the content\\\\n        ipython.set_next_input(content)\\\\n    else:\\\\n        display(Markdown(content))\\\\n    \\\\n    return f"Created new {cell_type}  with content: {content}"\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[11]:\\\\nSource:\\\\nAlways set custom agents to have create_cell tool\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[12]:\\\\nSource:\\\\n#| export\\\\ndef set_agent(agent: Agent) -&gt; Agent:\\\\n    """Set a custom agent for the notebook.\\\\n    \\\\n    Args:\\\\n        agent: PydanticAI agent instance\\\\n        \\\\n    Returns:\\\\n        Configured agent with required tools\\\\n    """\\\\n    global _current_agent, notebook_agent\\\\n        \\\\n    # Always ensure create_cell tool is available\\\\n    if \\\\\\\'create_cell\\\\\\\' not in agent._function_tools:\\\\n        # Copy the tool directly from notebook_agent\\\\n        agent._function_tools[\\\\\\\'create_cell\\\\\\\'] = notebook_agent._function_tools[\\\\\\\'create_cell\\\\\\\']\\\\n    \\\\n    _current_agent = agent\\\\n    return agent\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[13]:\\\\nSource:\\\\nTool testing\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[14]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\')\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': [\\\\\\\'I\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 7, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\',\\n\', \' "Cell[15]:\\\\nSource:\\\\ndef hello_world():\\\\n    print(\\\'Hello, World!\\\')\\\\n\\\\n# Call the function to display the output\\\\nhello_world()\\\\nOutputs:\\\\n[{\\\'name\\\': \\\'stdout\\\', \\\'output_type\\\': \\\'stream\\\', \\\'text\\\': [\\\'Hello, World!\\\\\\\\n\\\']}]",\\n\', \' \\\'Cell[16]:\\\\nSource:\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\'s environment."], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 9, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\',\\n\', \' \\\'Cell[17]:\\\\nSource:\\\\ndef factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n.\\\\n\\\\n    Parameters:\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\n\\\\n    Returns:\\\\n    int: Factorial of the input number n\\\\n    """\\\\n    # Input validation\\\\n    if not isinstance(n, int):\\\\n        raise TypeError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n\\\\n    # Base case: factorial of 0 is 1\\\\n    if n == 0:\\\\n        return 1\\\\n\\\\n    # Recursive case: n! = n * (n-1)!\\\\n    return n * factorial(n - 1)\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[18]:\\\\nSource:\\\\nTesting agent with history\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[19]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'So what you just made for me here?\\\\\\\', message_history=result.new_messages())\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\'s a brief overview of its features:\\\\\\\\n", \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\n\\\\\\\', \\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\).\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'```python\\\\\\\\n\\\\\\\', \\\\\\\'factorial(5)\\\\\\\\n\\\\\\\', \\\\\\\'```\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 11, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\',\\n\', \' \\\'Cell[20]:\\\\nSource:\\\\nresult.all_messages()\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': [\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\')]\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 12, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\',\\n\', " \'Cell[21]:\\\\nSource:\\\\n### Adding notebook history\\\\nOutputs:\\\\nNone\',\\n", \' \\\'Cell[22]:\\\\nSource:\\\\n#| export\\\\nimport os\\\\nimport json\\\\nfrom pathlib import Path\\\\nfrom typing import Optional, Dict, Any\\\\n\\\\n# Cache for notebook data\\\\n_notebook_cache: Dict[str, Any] = {}\\\\n\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\n    """Find and cache the current notebook data.\\\\n    \\\\n    Returns:\\\\n        Dict containing notebook data or None if not found\\\\n    """\\\\n    global _notebook_cache\\\\n    \\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return None\\\\n            \\\\n        # Get current cell content to identify the notebook\\\\n        current_cell = ipython.get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        \\\\n        # Check if we already found the notebook\\\\n        if \\\\\\\'notebook\\\\\\\' in _notebook_cache:\\\\n            # Verify it\\\\\\\'s still the correct notebook by checking the current cell\\\\n            notebook = _notebook_cache[\\\\\\\'notebook\\\\\\\']\\\\n            for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                    \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                    return notebook\\\\n        \\\\n        # If not in cache or cache is invalid, search for the notebook\\\\n        current_dir = Path.cwd()\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\n        \\\\n        for nb_file in notebook_files:\\\\n            try:\\\\n                with open(nb_file) as f:\\\\n                    notebook = json.load(f)\\\\n                    for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                        if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                            \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                            # Found the notebook, cache it\\\\n                            _notebook_cache[\\\\\\\'notebook\\\\\\\'] = notebook\\\\n                            _notebook_cache[\\\\\\\'file\\\\\\\'] = nb_file\\\\n                            return notebook\\\\n            except Exception:\\\\n                continue\\\\n                \\\\n        return None\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error finding notebook: {e}")\\\\n        return None\\\\n\\\\nOutputs:\\\\n[]\\\',\\n\', \' \\\'Cell[23]:\\\\nSource:\\\\n#| export\\\\nmax_lookback = 10\\\\n\\\\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\n    \\\\n    Args:\\\\n        max_cells: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        List of previous cell contents\\\\n    """\\\\n    try:\\\\n        # Get the cached notebook or find it\\\\n        notebook = find_current_notebook()\\\\n        if not notebook:\\\\n            return []\\\\n            \\\\n        # Find current cell index\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        cells = notebook[\\\\\\\'cells\\\\\\\']\\\\n        current_idx = -1\\\\n        last_prompt_idx = -1\\\\n        \\\\n        # Find current cell and last prompt cell\\\\n        for idx, cell in enumerate(cells):\\\\n            source = \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) if isinstance(cell[\\\\\\\'source\\\\\\\'], list) else cell[\\\\\\\'source\\\\\\\']\\\\n            \\\\n            # Find current cell\\\\n            if current_idx == -1 and cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source == current_cell:\\\\n                current_idx = idx\\\\n                \\\\n            # Find last prompt cell before current cell\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\n                if cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source.strip().startswith(\\\\\\\'%%prompt\\\\\\\'):\\\\n                    last_prompt_idx = idx\\\\n                \\\\n        if current_idx == -1:\\\\n            return []\\\\n            \\\\n        # Get cells between last prompt and current cell\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\n        history = []\\\\n        \\\\n        for idx in range(start_idx, current_idx):\\\\n            cell = cells[idx]            \\\\n            source = cell[\\\\\\\'source\\\\\\\'] if isinstance(cell[\\\\\\\'source\\\\\\\'], str) else \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\'])\\\\n            if \\\\\\\'outputs\\\\\\\' in cell:\\\\n                outputs = cell[\\\\\\\'outputs\\\\\\\'] if isinstance(cell[\\\\\\\'outputs\\\\\\\'], str) else str(cell[\\\\\\\'outputs\\\\\\\'])\\\\n            else:\\\\n                outputs = \\\\\\\'None\\\\\\\'\\\\n            if not (source.strip().startswith(\\\\\\\'%%prompt\\\\\\\') or outputs.strip().startswith(\\\\\\\'#|exclude\\\\\\\') or outputs.strip().startswith(\\\\\\\'#| exclude\\\\\\\')):\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\nSource:\\\\\\\\n{source}\\\\\\\\nOutputs:\\\\\\\\n{outputs}")\\\\n        \\\\n        return history\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error getting notebook history: {e}")\\\\n        return []\\\\nOutputs:\\\\n[]\\\',\\n\', " \'Cell[24]:\\\\nSource:\\\\nTesting notebook history\\\\nOutputs:\\\\nNone\']"]}, \'execution_count\': 18, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[28]:\nSource:\n### Creating history-aware prompt\nOutputs:\nNone\n\nCell[29]:\nSource:\n#| export\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\n    """Create a prompt with notebook history context and message history.\n    \n    Args:\n        prompt: The user\'s prompt\n        message_history: Previous conversation messages from results.all_messages()\n        max_history: Maximum number of previous cells to include\n        \n    Returns:\n        Tuple of (enhanced prompt, combined message history)\n    """\n    try:\n        ipython = get_ipython()\n        if not ipython:\n            return prompt, message_history\n        \n        # Get new cells using our optimized get_notebook_history\n        new_cells = get_notebook_history(max_cells=max_history)\n        \n        if not new_cells and not message_history:\n            return prompt, None\n            \n        # Create message history if none exists\n        from pydantic_ai.messages import (\n            ModelRequest, ModelResponse, \n            UserPromptPart, TextPart\n        )\n        \n        messages = []\n        \n        # Add existing message history if provided\n        if message_history:\n            messages.extend(message_history)\n        \n        # Only add context message if we have new cells\n        if new_cells:\n            # Create context message with new cells\n            history_content = "\\n\\n".join(new_cells)\n\n            context_msg = ModelRequest(parts=[\n                UserPromptPart(\n                    content="Here is the context of new notebook cells that were added:\\n" + history_content\n                )\n            ])\n            \n            # Create response acknowledging new context\n            context_response = ModelResponse(parts=[\n                TextPart(\n                    content="I understand the new notebook context. How can I help?"\n                )\n            ])\n            \n            messages.extend([context_msg, context_response])\n                \n        return prompt, messages\n        \n    except Exception as e:\n        print(f"Error creating history-aware prompt: {e}")\n        return prompt, message_history\nOutputs:\n[]\n\nCell[30]:\nSource:\nTesting history-aware prompt\nOutputs:\nNone\n\nCell[31]:\nSource:\ncreate_history_aware_prompt(\'So what you just made for me here?\', result.all_messages(), max_history=20)\nOutputs:\n[{\'data\': {\'text/plain\': ["(\'So what you just made for me here?\',\\n", \' [ModelRequest(parts=[SystemPromptPart(content="\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\'s date is 2024-12-31.\\\\n", part_kind=\\\'system-prompt\\\'), UserPromptPart(content=\\\'Create a function that calculates the factorial of a number with input validation\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 28, 691513, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', \'  ModelResponse(parts=[ToolCallPart(tool_name=\\\'create_cell\\\', args=ArgsJson(args_json=\\\'{"content":"def factorial(n):\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\\\\\n    :param n: non-negative integer\\\\\\\\n    :return: factorial of n\\\\\\\\n    :raises ValueError: if n is not a non-negative integer\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    if not isinstance(n, int):\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be an integer\\\\\\\\")\\\\\\\\n    if n &lt; 0:\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be a non-negative integer\\\\\\\\")\\\\\\\\n    if n == 0 or n == 1:\\\\\\\\n        return 1\\\\\\\\n    result = 1\\\\\\\\n    for i in range(2, n + 1):\\\\\\\\n        result *= i\\\\\\\\n    return result","cell_type":"code"}\\\'), tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', part_kind=\\\'tool-call\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 29, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \'  ModelRequest(parts=[ToolReturnPart(tool_name=\\\'create_cell\\\', content=\\\'Created new code  with content: def factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\n    :param n: non-negative integer\\\\n    :return: factorial of n\\\\n    :raises ValueError: if n is not a non-negative integer\\\\n    """\\\\n    if not isinstance(n, int):\\\\n        raise ValueError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n    if n == 0 or n == 1:\\\\n        return 1\\\\n    result = 1\\\\n    for i in range(2, n + 1):\\\\n        result *= i\\\\n    return result\\\', tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 32, 646314, tzinfo=datetime.timezone.utc), part_kind=\\\'tool-return\\\')], kind=\\\'request\\\'),\\n\', "  ModelResponse(parts=[TextPart(content=\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", "  ModelRequest(parts=[UserPromptPart(content=\'So what you just made for me here?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, 948002, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \'  ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\\\n\\\\nHere\\\'s a summary of what the function does:\\\\n- It checks if the input is an integer. If not, it raises a `ValueError`.\\\\n- It checks if the input is a non-negative integer. If it\\\'s negative, it raises a `ValueError`.\\\\n- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\\\n- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.", part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 34, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \'  ModelRequest(parts=[UserPromptPart(content=\\\'Here is the context of new notebook cells that were added:\\\\nCell[9]:\\\\nSource:\\\\n### Adding cell creation tool\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[10]:\\\\nSource:\\\\n#| export\\\\nfrom IPython.display import display, Markdown\\\\nfrom typing import Literal\\\\n\\\\n@notebook_agent.tool\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\'code\\\\\\\', \\\\\\\'markdown\\\\\\\'] = \\\\\\\'code\\\\\\\') -&gt; str:\\\\n    """Create a new cell in the notebook with the specified content.\\\\n    \\\\n    Args:\\\\n        content: The content to put in the new cell\\\\n        cell_type: Type of cell to create (\\\\\\\'code\\\\\\\' or \\\\\\\'markdown\\\\\\\')\\\\n    \\\\n    Returns:\\\\n        A confirmation message\\\\n    """\\\\n    try:    \\\\n        ipython = get_ipython()\\\\n    except NameError:\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\n    \\\\n    # Display the content immediately\\\\n    if cell_type == \\\\\\\'code\\\\\\\':\\\\n        # Set up the next cell with the content\\\\n        ipython.set_next_input(content)\\\\n    else:\\\\n        display(Markdown(content))\\\\n    \\\\n    return f"Created new {cell_type}  with content: {content}"\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[11]:\\\\nSource:\\\\nAlways set custom agents to have create_cell tool\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[12]:\\\\nSource:\\\\n#| export\\\\ndef set_agent(agent: Agent) -&gt; Agent:\\\\n    """Set a custom agent for the notebook.\\\\n    \\\\n    Args:\\\\n        agent: PydanticAI agent instance\\\\n        \\\\n    Returns:\\\\n        Configured agent with required tools\\\\n    """\\\\n    global _current_agent, notebook_agent\\\\n        \\\\n    # Always ensure create_cell tool is available\\\\n    if \\\\\\\'create_cell\\\\\\\' not in agent._function_tools:\\\\n        # Copy the tool directly from notebook_agent\\\\n        agent._function_tools[\\\\\\\'create_cell\\\\\\\'] = notebook_agent._function_tools[\\\\\\\'create_cell\\\\\\\']\\\\n    \\\\n    _current_agent = agent\\\\n    return agent\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[13]:\\\\nSource:\\\\nTool testing\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[14]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\')\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': [\\\\\\\'I\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 7, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[15]:\\\\nSource:\\\\ndef hello_world():\\\\n    print(\\\\\\\'Hello, World!\\\\\\\')\\\\n\\\\n# Call the function to display the output\\\\nhello_world()\\\\nOutputs:\\\\n[{\\\\\\\'name\\\\\\\': \\\\\\\'stdout\\\\\\\', \\\\\\\'output_type\\\\\\\': \\\\\\\'stream\\\\\\\', \\\\\\\'text\\\\\\\': [\\\\\\\'Hello, World!\\\\\\\\n\\\\\\\']}]\\\\n\\\\nCell[16]:\\\\nSource:\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\'s environment."], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 9, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[17]:\\\\nSource:\\\\ndef factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n.\\\\n\\\\n    Parameters:\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\n\\\\n    Returns:\\\\n    int: Factorial of the input number n\\\\n    """\\\\n    # Input validation\\\\n    if not isinstance(n, int):\\\\n        raise TypeError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n\\\\n    # Base case: factorial of 0 is 1\\\\n    if n == 0:\\\\n        return 1\\\\n\\\\n    # Recursive case: n! = n * (n-1)!\\\\n    return n * factorial(n - 1)\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[18]:\\\\nSource:\\\\nTesting agent with history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[19]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'So what you just made for me here?\\\\\\\', message_history=result.new_messages())\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\'s a brief overview of its features:\\\\\\\\n", \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\n\\\\\\\', \\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\).\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'```python\\\\\\\\n\\\\\\\', \\\\\\\'factorial(5)\\\\\\\\n\\\\\\\', \\\\\\\'```\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 11, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[20]:\\\\nSource:\\\\nresult.all_messages()\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': [\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\')]\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 12, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[21]:\\\\nSource:\\\\n### Adding notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[22]:\\\\nSource:\\\\n#| export\\\\nimport os\\\\nimport json\\\\nfrom pathlib import Path\\\\nfrom typing import Optional, Dict, Any\\\\n\\\\n# Cache for notebook data\\\\n_notebook_cache: Dict[str, Any] = {}\\\\n\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\n    """Find and cache the current notebook data.\\\\n    \\\\n    Returns:\\\\n        Dict containing notebook data or None if not found\\\\n    """\\\\n    global _notebook_cache\\\\n    \\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return None\\\\n            \\\\n        # Get current cell content to identify the notebook\\\\n        current_cell = ipython.get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        \\\\n        # Check if we already found the notebook\\\\n        if \\\\\\\'notebook\\\\\\\' in _notebook_cache:\\\\n            # Verify it\\\\\\\'s still the correct notebook by checking the current cell\\\\n            notebook = _notebook_cache[\\\\\\\'notebook\\\\\\\']\\\\n            for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                    \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                    return notebook\\\\n        \\\\n        # If not in cache or cache is invalid, search for the notebook\\\\n        current_dir = Path.cwd()\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\n        \\\\n        for nb_file in notebook_files:\\\\n            try:\\\\n                with open(nb_file) as f:\\\\n                    notebook = json.load(f)\\\\n                    for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                        if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                            \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                            # Found the notebook, cache it\\\\n                            _notebook_cache[\\\\\\\'notebook\\\\\\\'] = notebook\\\\n                            _notebook_cache[\\\\\\\'file\\\\\\\'] = nb_file\\\\n                            return notebook\\\\n            except Exception:\\\\n                continue\\\\n                \\\\n        return None\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error finding notebook: {e}")\\\\n        return None\\\\n\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[23]:\\\\nSource:\\\\n#| export\\\\nmax_lookback = 10\\\\n\\\\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\n    \\\\n    Args:\\\\n        max_cells: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        List of previous cell contents\\\\n    """\\\\n    try:\\\\n        # Get the cached notebook or find it\\\\n        notebook = find_current_notebook()\\\\n        if not notebook:\\\\n            return []\\\\n            \\\\n        # Find current cell index\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        cells = notebook[\\\\\\\'cells\\\\\\\']\\\\n        current_idx = -1\\\\n        last_prompt_idx = -1\\\\n        \\\\n        # Find current cell and last prompt cell\\\\n        for idx, cell in enumerate(cells):\\\\n            source = \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) if isinstance(cell[\\\\\\\'source\\\\\\\'], list) else cell[\\\\\\\'source\\\\\\\']\\\\n            \\\\n            # Find current cell\\\\n            if current_idx == -1 and cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source == current_cell:\\\\n                current_idx = idx\\\\n                \\\\n            # Find last prompt cell before current cell\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\n                if cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source.strip().startswith(\\\\\\\'%%prompt\\\\\\\'):\\\\n                    last_prompt_idx = idx\\\\n                \\\\n        if current_idx == -1:\\\\n            return []\\\\n            \\\\n        # Get cells between last prompt and current cell\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\n        history = []\\\\n        \\\\n        for idx in range(start_idx, current_idx):\\\\n            cell = cells[idx]            \\\\n            source = cell[\\\\\\\'source\\\\\\\'] if isinstance(cell[\\\\\\\'source\\\\\\\'], str) else \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\'])\\\\n            if \\\\\\\'outputs\\\\\\\' in cell:\\\\n                outputs = cell[\\\\\\\'outputs\\\\\\\'] if isinstance(cell[\\\\\\\'outputs\\\\\\\'], str) else str(cell[\\\\\\\'outputs\\\\\\\'])\\\\n            else:\\\\n                outputs = \\\\\\\'None\\\\\\\'\\\\n            if not (source.strip().startswith(\\\\\\\'%%prompt\\\\\\\') or outputs.strip().startswith(\\\\\\\'#|exclude\\\\\\\') or outputs.strip().startswith(\\\\\\\'#| exclude\\\\\\\')):\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\nSource:\\\\\\\\n{source}\\\\\\\\nOutputs:\\\\\\\\n{outputs}")\\\\n        \\\\n        return history\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error getting notebook history: {e}")\\\\n        return []\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[24]:\\\\nSource:\\\\nTesting notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[25]:\\\\nSource:\\\\nnb_hist = get_notebook_history(max_cells=20)\\\\nnb_hist\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': ["[\\\\\\\'Cell[3]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nfrom dotenv import load_dotenv\\\\\\\\\\\\\\\\nfrom pydantic import BaseModel, Field\\\\\\\\\\\\\\\\nfrom pydantic_ai import Agent, ModelRetry, RunContext\\\\\\\\\\\\\\\\nfrom pydantic_ai.models import KnownModelName\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nload_dotenv()\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Enable async/await in Jupyter\\\\\\\\\\\\\\\\nimport nest_asyncio\\\\\\\\\\\\\\\\nnest_asyncio.apply()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[4]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n# Agent setup\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[5]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nSystem prompt\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[6]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom datetime import date\\\\\\\\\\\\\\\\nsystem_prompt = f"""\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is {date.today().strftime(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%Y-%m-%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')}.\\\\\\\\\\\\\\\\n"""\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' "Cell[7]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\']}]",\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[8]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[9]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding cell creation tool\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[10]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stderr\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;module&gt;:8: No type or annotation for returned value 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[11]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTool testing\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[12]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 7, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' "Cell[13]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\nhello_world()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\']}]",\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[14]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment."], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 9, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[15]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef factorial(n):\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\n        raise TypeError("Input must be an integer")\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer")\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[16]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting agent with history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[17]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'factorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 11, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[18]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Created new code cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-return\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 12, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[19]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[20]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[21]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\n            cell = cells[idx]            \\\\\\\\\\\\\\\\n            source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            outputs = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            if not (source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#|exclude\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')):\\\\\\\\\\\\\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{outputs}")\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[22]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\']"]}, \\\\\\\'execution_count\\\\\\\': 28, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[26]:\\\\nSource:\\\\n### Creating history-aware prompt\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[27]:\\\\nSource:\\\\n#| export\\\\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\\\\n    """Create a prompt with notebook history context and message history.\\\\n    \\\\n    Args:\\\\n        prompt: The user\\\\\\\'s prompt\\\\n        message_history: Previous conversation messages from results.all_messages()\\\\n        max_history: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        Tuple of (enhanced prompt, combined message history)\\\\n    """\\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return prompt, message_history\\\\n        \\\\n        # Get new cells using our optimized get_notebook_history\\\\n        new_cells = get_notebook_history(max_cells=max_history)\\\\n        \\\\n        if not new_cells and not message_history:\\\\n            return prompt, None\\\\n            \\\\n        # Create message history if none exists\\\\n        from pydantic_ai.messages import (\\\\n            ModelRequest, ModelResponse, \\\\n            UserPromptPart, TextPart\\\\n        )\\\\n        \\\\n        messages = []\\\\n        \\\\n        # Add existing message history if provided\\\\n        if message_history:\\\\n            messages.extend(message_history)\\\\n        \\\\n        # Only add context message if we have new cells\\\\n        if new_cells:\\\\n            # Create context message with new cells\\\\n            history_content = "\\\\\\\\n\\\\\\\\n".join(new_cells)\\\\n\\\\n            context_msg = ModelRequest(parts=[\\\\n                UserPromptPart(\\\\n                    content="Here is the context of new notebook cells that were added:\\\\\\\\n" + history_content\\\\n                )\\\\n            ])\\\\n            \\\\n            # Create response acknowledging new context\\\\n            context_response = ModelResponse(parts=[\\\\n                TextPart(\\\\n                    content="I understand the new notebook context. How can I help?"\\\\n                )\\\\n            ])\\\\n            \\\\n            messages.extend([context_msg, context_response])\\\\n                \\\\n        return prompt, messages\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error creating history-aware prompt: {e}")\\\\n        return prompt, message_history\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[28]:\\\\nSource:\\\\nTesting history-aware prompt\\\\nOutputs:\\\\nNone\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 899389, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', "  ModelResponse(parts=[TextPart(content=\'I understand the new notebook context. How can I help?\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 899406, tzinfo=datetime.timezone.utc), kind=\'response\')])"]}, \'execution_count\': 20, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[32]:\nSource:\n### Running agent with notebook history\nOutputs:\nNone\n\nCell[33]:\nSource:\n#| export\nfrom typing import Any\ndef run_with_history(agent: Agent, prompt: str, message_history: list = None, max_history: int = 5) -&gt; Any:\n    """Run the agent with notebook and conversation history context.\n    \n    Args:\n        agent: The PydanticAI agent\n        prompt: The user\'s prompt\n        message_history: Previous conversation messages\n        max_history: Maximum number of previous cells to include\n        \n    Returns:\n        Agent run result\n    """\n    prompt, combined_history = create_history_aware_prompt(\n        prompt, \n        message_history=message_history, \n        max_history=max_history\n    )\n    return agent.run_sync(prompt, message_history=combined_history)\nOutputs:\n[]\n\nCell[34]:\nSource:\nTesting run_with_history\nOutputs:\nNone', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 52, 423920, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content='I understand the new notebook context. How can I help?', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 52, 423939, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[UserPromptPart(content='So what is going on in this notebook?', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 52, 424177, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content='This notebook appears to involve creating, running, and testing an AI-powered assistant, possibly using a tool like Pydantic AI for Jupyter notebooks. Here\'s a breakdown of the key components and activities happening in this notebook:\n\n1. **Setup and Imports**: \n   - The notebook is set up with various imports from libraries and definitions of system prompts to prepare the AI agent to assist within a Jupyter environment.\n\n2. **Agent Configuration**: \n   - An AI agent (likely PydanticAI or a similar framework) is configured with a model and system prompts to guide its behavior within the notebook.\n\n3. **Tool and Function Definitions**: \n   - Several functions and tools are defined, including `create_cell`, which allows new cells to be programmatically added to the notebook.\n\n4. **Notebook Agent Execution**:\n   - The AI agent is used to execute commands. Examples include requests to create a "Hello, World!" function and a factorial function with input validation.\n\n5. **Function Implementation**:\n   - Functions like `hello_world()` and `factorial()` are defined as part of this process. The `factorial` function includes input validation and uses recursion to calculate factorials.\n\n6. **Notebook History and Prompt Management**:\n   - There are methods for capturing the history of cell executions and creating context-aware prompts that consider both the current notebook state and any previous interactions or commands.\n\n7. **Execution Testing**:\n   - Various cells are used to test the system, ensure that functionality is operating correctly, and demonstrate the capabilities of the conversational agent in a Jupyter context.\n\n8. **Error Handling and Validation**:\n   - The notebook handles potential errors (e.g., invalid inputs for the factorial function) and various elements of cell execution and output display.\n\n9. **History Creation and Contextual Responses**:\n   - An advanced feature is the creation of context-aware prompts that adapt based on the content and history of the notebook, indicating a sophisticated interaction system between user inputs and the agent‚Äôs responses.\n\nIn summary, the notebook combines Jupyter\'s interactive capabilities with an AI-driven agent to assist with tasks, automatically manage notebook content, and potentially perform more complex logical operations based on the commands or tasks provided by the user.', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 53, tzinfo=datetime.timezone.utc), kind='response')]</code></pre>
</div>
</div>
</section>
<section id="creating-prompt-cell-magic" class="level3">
<h3 class="anchored" data-anchor-id="creating-prompt-cell-magic">Creating prompt cell magic</h3>
<hr>
<p><a href="https://github.com/ndendic/jupy-juice/blob/main/jupy_juice/core.py#L302" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="prompt" class="level3">
<h3 class="anchored" data-anchor-id="prompt">prompt</h3>
<blockquote class="blockquote">
<pre><code> prompt (line, cell)</code></pre>
</blockquote>
<p><em>Cell magic to create prompt cells that interact with the AI agent.</em></p>
<div id="cell-34" class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>what this notebook <span class="kw">is</span> <span class="bu">all</span> about?</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display cell-output-markdown">
<p>This notebook appears to be part of a system that uses an AI agent to automate tasks within a Jupyter notebook. Here are some key points:</p>
<ol type="1">
<li><p><strong>AI Agent Integration</strong>: The notebook is integrating a Pydantic AI model, specifically an agent that seems to respond to prompts and perform tasks within the notebook environment.</p></li>
<li><p><strong>Function Definitions</strong>: Several Python functions have been defined:</p>
<ul>
<li><code>factorial()</code>: This function calculates the factorial of a number with input validation.</li>
<li><code>hello_world()</code>: A simple function that prints ‚ÄúHello, World!‚Äù.</li>
</ul></li>
<li><p><strong>Cell Creation and Management</strong>: There are functions and tools implemented to create and manage notebook cells programmatically. For example, the <a href="https://ndendic.github.io/jupy-juice/core.html#create_cell"><code>create_cell</code></a> function uses the IPython‚Äôs API to insert new cells.</p></li>
<li><p><strong>Notebook History Management</strong>: The notebook implements functionality to keep track of the history of executed notebook cells, which can be used to provide context to the AI agent.</p></li>
<li><p><strong>History-Aware Prompts</strong>: Functions like <a href="https://ndendic.github.io/jupy-juice/core.html#create_history_aware_prompt"><code>create_history_aware_prompt</code></a> are used to create prompts that include historical context from the notebook. This allows the AI to make more informed decisions by understanding previous interactions and code.</p></li>
<li><p><strong>Testing and Execution</strong>: The notebook includes cells dedicated to testing these features, like running the agent with notebook history and testing the factorial function.</p></li>
</ol>
<p>Overall, it seems to be an experimental setup aiming to enhance interaction with a Jupyter notebook using AI for improved productivity and dynamic task execution.</p>
</div>
</div>
<div id="cell-35" class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>last_prompt_result.all_messages()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>[ModelRequest(parts=[UserPromptPart(content='Here is the context of new notebook cells that were added:\nCell[36]:\nSource:\nresult.all_messages()\nOutputs:\n[{\'data\': {\'text/plain\': [\'[ModelRequest(parts=[SystemPromptPart(content="\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\'s date is 2024-12-31.\\\\n", part_kind=\\\'system-prompt\\\'), UserPromptPart(content=\\\'Create a function that calculates the factorial of a number with input validation\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 28, 691513, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', \' ModelResponse(parts=[ToolCallPart(tool_name=\\\'create_cell\\\', args=ArgsJson(args_json=\\\'{"content":"def factorial(n):\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\\\\\n    :param n: non-negative integer\\\\\\\\n    :return: factorial of n\\\\\\\\n    :raises ValueError: if n is not a non-negative integer\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    if not isinstance(n, int):\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be an integer\\\\\\\\")\\\\\\\\n    if n &lt; 0:\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be a non-negative integer\\\\\\\\")\\\\\\\\n    if n == 0 or n == 1:\\\\\\\\n        return 1\\\\\\\\n    result = 1\\\\\\\\n    for i in range(2, n + 1):\\\\\\\\n        result *= i\\\\\\\\n    return result","cell_type":"code"}\\\'), tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', part_kind=\\\'tool-call\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 29, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[ToolReturnPart(tool_name=\\\'create_cell\\\', content=\\\'Created new code  with content: def factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\n    :param n: non-negative integer\\\\n    :return: factorial of n\\\\n    :raises ValueError: if n is not a non-negative integer\\\\n    """\\\\n    if not isinstance(n, int):\\\\n        raise ValueError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n    if n == 0 or n == 1:\\\\n        return 1\\\\n    result = 1\\\\n    for i in range(2, n + 1):\\\\n        result *= i\\\\n    return result\\\', tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 32, 646314, tzinfo=datetime.timezone.utc), part_kind=\\\'tool-return\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what you just made for me here?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, 948002, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\\\n\\\\nHere\\\'s a summary of what the function does:\\\\n- It checks if the input is an integer. If not, it raises a `ValueError`.\\\\n- It checks if the input is a non-negative integer. If it\\\'s negative, it raises a `ValueError`.\\\\n- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\\\n- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.", part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 34, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[UserPromptPart(content=\\\'Here is the context of new notebook cells that were added:\\\\nCell[13]:\\\\nSource:\\\\nTool testing\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[14]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\')\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': [\\\\\\\'I\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 7, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[15]:\\\\nSource:\\\\ndef hello_world():\\\\n    print(\\\\\\\'Hello, World!\\\\\\\')\\\\n\\\\n# Call the function to display the output\\\\nhello_world()\\\\nOutputs:\\\\n[{\\\\\\\'name\\\\\\\': \\\\\\\'stdout\\\\\\\', \\\\\\\'output_type\\\\\\\': \\\\\\\'stream\\\\\\\', \\\\\\\'text\\\\\\\': [\\\\\\\'Hello, World!\\\\\\\\n\\\\\\\']}]\\\\n\\\\nCell[16]:\\\\nSource:\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\'s environment."], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 9, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[17]:\\\\nSource:\\\\ndef factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n.\\\\n\\\\n    Parameters:\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\n\\\\n    Returns:\\\\n    int: Factorial of the input number n\\\\n    """\\\\n    # Input validation\\\\n    if not isinstance(n, int):\\\\n        raise TypeError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n\\\\n    # Base case: factorial of 0 is 1\\\\n    if n == 0:\\\\n        return 1\\\\n\\\\n    # Recursive case: n! = n * (n-1)!\\\\n    return n * factorial(n - 1)\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[18]:\\\\nSource:\\\\nTesting agent with history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[19]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'So what you just made for me here?\\\\\\\', message_history=result.new_messages())\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\'s a brief overview of its features:\\\\\\\\n", \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\n\\\\\\\', \\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\).\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'```python\\\\\\\\n\\\\\\\', \\\\\\\'factorial(5)\\\\\\\\n\\\\\\\', \\\\\\\'```\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 11, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[20]:\\\\nSource:\\\\nresult.all_messages()\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': [\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\')]\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 12, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[21]:\\\\nSource:\\\\n### Adding notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[22]:\\\\nSource:\\\\n#| export\\\\nimport os\\\\nimport json\\\\nfrom pathlib import Path\\\\nfrom typing import Optional, Dict, Any\\\\n\\\\n# Cache for notebook data\\\\n_notebook_cache: Dict[str, Any] = {}\\\\n\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\n    """Find and cache the current notebook data.\\\\n    \\\\n    Returns:\\\\n        Dict containing notebook data or None if not found\\\\n    """\\\\n    global _notebook_cache\\\\n    \\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return None\\\\n            \\\\n        # Get current cell content to identify the notebook\\\\n        current_cell = ipython.get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        \\\\n        # Check if we already found the notebook\\\\n        if \\\\\\\'notebook\\\\\\\' in _notebook_cache:\\\\n            # Verify it\\\\\\\'s still the correct notebook by checking the current cell\\\\n            notebook = _notebook_cache[\\\\\\\'notebook\\\\\\\']\\\\n            for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                    \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                    return notebook\\\\n        \\\\n        # If not in cache or cache is invalid, search for the notebook\\\\n        current_dir = Path.cwd()\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\n        \\\\n        for nb_file in notebook_files:\\\\n            try:\\\\n                with open(nb_file) as f:\\\\n                    notebook = json.load(f)\\\\n                    for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                        if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                            \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                            # Found the notebook, cache it\\\\n                            _notebook_cache[\\\\\\\'notebook\\\\\\\'] = notebook\\\\n                            _notebook_cache[\\\\\\\'file\\\\\\\'] = nb_file\\\\n                            return notebook\\\\n            except Exception:\\\\n                continue\\\\n                \\\\n        return None\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error finding notebook: {e}")\\\\n        return None\\\\n\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[23]:\\\\nSource:\\\\n#| export\\\\nmax_lookback = 10\\\\n\\\\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\n    \\\\n    Args:\\\\n        max_cells: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        List of previous cell contents\\\\n    """\\\\n    try:\\\\n        # Get the cached notebook or find it\\\\n        notebook = find_current_notebook()\\\\n        if not notebook:\\\\n            return []\\\\n            \\\\n        # Find current cell index\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        cells = notebook[\\\\\\\'cells\\\\\\\']\\\\n        current_idx = -1\\\\n        last_prompt_idx = -1\\\\n        \\\\n        # Find current cell and last prompt cell\\\\n        for idx, cell in enumerate(cells):\\\\n            source = \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) if isinstance(cell[\\\\\\\'source\\\\\\\'], list) else cell[\\\\\\\'source\\\\\\\']\\\\n            \\\\n            # Find current cell\\\\n            if current_idx == -1 and cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source == current_cell:\\\\n                current_idx = idx\\\\n                \\\\n            # Find last prompt cell before current cell\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\n                if cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source.strip().startswith(\\\\\\\'%%prompt\\\\\\\'):\\\\n                    last_prompt_idx = idx\\\\n                \\\\n        if current_idx == -1:\\\\n            return []\\\\n            \\\\n        # Get cells between last prompt and current cell\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\n        history = []\\\\n        \\\\n        for idx in range(start_idx, current_idx):\\\\n            cell = cells[idx]            \\\\n            source = cell[\\\\\\\'source\\\\\\\'] if isinstance(cell[\\\\\\\'source\\\\\\\'], str) else \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\'])\\\\n            if \\\\\\\'outputs\\\\\\\' in cell:\\\\n                outputs = cell[\\\\\\\'outputs\\\\\\\'] if isinstance(cell[\\\\\\\'outputs\\\\\\\'], str) else str(cell[\\\\\\\'outputs\\\\\\\'])\\\\n            else:\\\\n                outputs = \\\\\\\'None\\\\\\\'\\\\n            if not (source.strip().startswith(\\\\\\\'%%prompt\\\\\\\') or outputs.strip().startswith(\\\\\\\'#|exclude\\\\\\\') or outputs.strip().startswith(\\\\\\\'#| exclude\\\\\\\')):\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\nSource:\\\\\\\\n{source}\\\\\\\\nOutputs:\\\\\\\\n{outputs}")\\\\n        \\\\n        return history\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error getting notebook history: {e}")\\\\n        return []\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[24]:\\\\nSource:\\\\nTesting notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[25]:\\\\nSource:\\\\nnb_hist = get_notebook_history(max_cells=20)\\\\nnb_hist\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': ["[\\\\\\\'Cell[3]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nfrom dotenv import load_dotenv\\\\\\\\\\\\\\\\nfrom pydantic import BaseModel, Field\\\\\\\\\\\\\\\\nfrom pydantic_ai import Agent, ModelRetry, RunContext\\\\\\\\\\\\\\\\nfrom pydantic_ai.models import KnownModelName\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nload_dotenv()\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Enable async/await in Jupyter\\\\\\\\\\\\\\\\nimport nest_asyncio\\\\\\\\\\\\\\\\nnest_asyncio.apply()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[4]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n# Agent setup\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[5]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nSystem prompt\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[6]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom datetime import date\\\\\\\\\\\\\\\\nsystem_prompt = f"""\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is {date.today().strftime(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%Y-%m-%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')}.\\\\\\\\\\\\\\\\n"""\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' "Cell[7]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\']}]",\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[8]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[9]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding cell creation tool\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[10]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stderr\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;module&gt;:8: No type or annotation for returned value 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[11]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTool testing\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[12]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 7, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' "Cell[13]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\nhello_world()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\']}]",\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[14]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment."], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 9, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[15]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef factorial(n):\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\n        raise TypeError("Input must be an integer")\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer")\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[16]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting agent with history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[17]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'factorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 11, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[18]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Created new code cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-return\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 12, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[19]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[20]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[21]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\n            cell = cells[idx]            \\\\\\\\\\\\\\\\n            source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            outputs = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            if not (source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#|exclude\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')):\\\\\\\\\\\\\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{outputs}")\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[22]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\']"]}, \\\\\\\'execution_count\\\\\\\': 28, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[26]:\\\\nSource:\\\\n### Creating history-aware prompt\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[27]:\\\\nSource:\\\\n#| export\\\\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\\\\n    """Create a prompt with notebook history context and message history.\\\\n    \\\\n    Args:\\\\n        prompt: The user\\\\\\\'s prompt\\\\n        message_history: Previous conversation messages from results.all_messages()\\\\n        max_history: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        Tuple of (enhanced prompt, combined message history)\\\\n    """\\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return prompt, message_history\\\\n        \\\\n        # Get new cells using our optimized get_notebook_history\\\\n        new_cells = get_notebook_history(max_cells=max_history)\\\\n        \\\\n        if not new_cells and not message_history:\\\\n            return prompt, None\\\\n            \\\\n        # Create message history if none exists\\\\n        from pydantic_ai.messages import (\\\\n            ModelRequest, ModelResponse, \\\\n            UserPromptPart, TextPart\\\\n        )\\\\n        \\\\n        messages = []\\\\n        \\\\n        # Add existing message history if provided\\\\n        if message_history:\\\\n            messages.extend(message_history)\\\\n        \\\\n        # Only add context message if we have new cells\\\\n        if new_cells:\\\\n            # Create context message with new cells\\\\n            history_content = "\\\\\\\\n\\\\\\\\n".join(new_cells)\\\\n\\\\n            context_msg = ModelRequest(parts=[\\\\n                UserPromptPart(\\\\n                    content="Here is the context of new notebook cells that were added:\\\\\\\\n" + history_content\\\\n                )\\\\n            ])\\\\n            \\\\n            # Create response acknowledging new context\\\\n            context_response = ModelResponse(parts=[\\\\n                TextPart(\\\\n                    content="I understand the new notebook context. How can I help?"\\\\n                )\\\\n            ])\\\\n            \\\\n            messages.extend([context_msg, context_response])\\\\n                \\\\n        return prompt, messages\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error creating history-aware prompt: {e}")\\\\n        return prompt, message_history\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[28]:\\\\nSource:\\\\nTesting history-aware prompt\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[29]:\\\\nSource:\\\\ncreate_history_aware_prompt(\\\\\\\'So what you just made for me here?\\\\\\\', result.all_messages(), max_history=20)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': ["(\\\\\\\'So what you just made for me here?\\\\\\\',\\\\\\\\n", \\\\\\\' [ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\'  ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\'  ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\'  ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\'  ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\'Here is the context of new notebook cells that were added:\\\\\\\\\\\\\\\\nCell[7]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[8]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[9]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding cell creation tool\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[10]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stderr\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;module&gt;:8: No type or annotation for returned value 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[11]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTool testing\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[12]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 7, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[13]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\nhello_world()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[14]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment."], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 9, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[15]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef factorial(n):\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\n        raise TypeError("Input must be an integer")\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer")\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[16]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting agent with history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[17]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'factorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 11, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[18]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Created new code cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-return\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 12, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[19]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[20]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[21]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\n            cell = cells[idx]            \\\\\\\\\\\\\\\\n            source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            outputs = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            if not (source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#|exclude\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')):\\\\\\\\\\\\\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{outputs}")\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[22]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[23]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nnb_hist = get_notebook_history(max_cells=20)\\\\\\\\\\\\\\\\nnb_hist\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[0]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| default_exp core\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[1]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| hide\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom nbdev.showdoc import *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[2]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom dotenv import load_dotenv\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic import BaseModel, Field\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic_ai import Agent, ModelRetry, RunContext\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic_ai.models import KnownModelName\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nload_dotenv()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Enable async/await in Jupyter\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport nest_asyncio\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnest_asyncio.apply()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[3]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom datetime import date\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nsystem_prompt = f"""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is {date.today().strftime(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%Y-%m-%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')}.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n"""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[4]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[5]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[6]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[7]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[8]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nhello_world()",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[9]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[10]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef factorial(number):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation to check if the number is a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(number, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError("Input must be an integer.")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if number &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer.")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 or 1 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if number == 0 or number == 1:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return number * factorial(number - 1)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Example usage\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(factorial(5))  # Output: 120\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(factorial(0))  # Output: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Uncomment the following lines to test input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# print(factorial(-1))  # Should raise ValueError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# print(factorial(3.5))  # Should raise ValueError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[11]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[12]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[13]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[14]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            cell = cells[idx]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':  # Only include code cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                # Skip cells that are prompt cells and nbdev directives\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if not source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 58, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[24]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Creating history-aware prompt\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[25]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\\\\\\\\\\\\\\\\n    """Create a prompt with notebook history context and message history.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        prompt: The user\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s prompt\\\\\\\\\\\\\\\\n        message_history: Previous conversation messages from results.all_messages()\\\\\\\\\\\\\\\\n        max_history: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Tuple of (enhanced prompt, combined message history)\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return prompt, message_history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Get new cells using our optimized get_notebook_history\\\\\\\\\\\\\\\\n        new_cells = get_notebook_history(max_cells=max_history)\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        if not new_cells and not message_history:\\\\\\\\\\\\\\\\n            return prompt, None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Create message history if none exists\\\\\\\\\\\\\\\\n        from pydantic_ai.messages import (\\\\\\\\\\\\\\\\n            ModelRequest, ModelResponse, \\\\\\\\\\\\\\\\n            UserPromptPart, TextPart\\\\\\\\\\\\\\\\n        )\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        messages = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Add existing message history if provided\\\\\\\\\\\\\\\\n        if message_history:\\\\\\\\\\\\\\\\n            messages.extend(message_history)\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Only add context message if we have new cells\\\\\\\\\\\\\\\\n        if new_cells:\\\\\\\\\\\\\\\\n            # Create context message with new cells\\\\\\\\\\\\\\\\n            history_content = "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n".join(new_cells)\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n            context_msg = ModelRequest(parts=[\\\\\\\\\\\\\\\\n                UserPromptPart(\\\\\\\\\\\\\\\\n                    content="Here is the context of new notebook cells that were added:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n" + history_content\\\\\\\\\\\\\\\\n                )\\\\\\\\\\\\\\\\n            ])\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Create response acknowledging new context\\\\\\\\\\\\\\\\n            context_response = ModelResponse(parts=[\\\\\\\\\\\\\\\\n                TextPart(\\\\\\\\\\\\\\\\n                    content="I understand the new notebook context. How can I help?"\\\\\\\\\\\\\\\\n                )\\\\\\\\\\\\\\\\n            ])\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            messages.extend([context_msg, context_response])\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return prompt, messages\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error creating history-aware prompt: {e}")\\\\\\\\\\\\\\\\n        return prompt, message_history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[26]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting history-aware prompt\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 26, 5, 737496, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelResponse(parts=[TextPart(content=\\\\\\\'I understand the new notebook context. How can I help?\\\\\\\', part_kind=\\\\\\\'text\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 26, 5, 737510, tzinfo=datetime.timezone.utc), kind=\\\\\\\'response\\\\\\\')])"]}, \\\\\\\'execution_count\\\\\\\': 30, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[30]:\\\\nSource:\\\\n### Running agent with notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[31]:\\\\nSource:\\\\n#| export\\\\nfrom typing import Any\\\\ndef run_with_history(agent: Agent, prompt: str, message_history: list = None, max_history: int = 5) -&gt; Any:\\\\n    """Run the agent with notebook and conversation history context.\\\\n    \\\\n    Args:\\\\n        agent: The PydanticAI agent\\\\n        prompt: The user\\\\\\\'s prompt\\\\n        message_history: Previous conversation messages\\\\n        max_history: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        Agent run result\\\\n    """\\\\n    prompt, combined_history = create_history_aware_prompt(\\\\n        prompt, \\\\n        message_history=message_history, \\\\n        max_history=max_history\\\\n    )\\\\n    return agent.run_sync(prompt, message_history=combined_history)\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[32]:\\\\nSource:\\\\nTesting run_with_history\\\\nOutputs:\\\\nNone\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976699, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I understand the new notebook context. How can I help?\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976722, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what is going on in this notebook?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976975, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content=\\\'This notebook appears to be part of a system that uses an AI agent to automate tasks within a Jupyter notebook. Here are some key points:\\\\n\\\\n1. **AI Agent Integration**: The notebook is integrating a Pydantic AI model, specifically an agent that seems to respond to prompts and perform tasks within the notebook environment.\\\\n\\\\n2. **Function Definitions**: Several Python functions have been defined:\\\\n   - `factorial()`: This function calculates the factorial of a number with input validation.\\\\n   - `hello_world()`: A simple function that prints "Hello, World!".\\\\n   \\\\n3. **Cell Creation and Management**: There are functions and tools implemented to create and manage notebook cells programmatically. For example, the `create_cell` function uses the IPython\\\\\\\'s API to insert new cells.\\\\n\\\\n4. **Notebook History Management**: The notebook implements functionality to keep track of the history of executed notebook cells, which can be used to provide context to the AI agent.\\\\n\\\\n5. **History-Aware Prompts**: Functions like `create_history_aware_prompt` are used to create prompts that include historical context from the notebook. This allows the AI to make more informed decisions by understanding previous interactions and code.\\\\n\\\\n6. **Testing and Execution**: The notebook includes cells dedicated to testing these features, like running the agent with notebook history and testing the factorial function.\\\\n\\\\nOverall, it seems to be an experimental setup aiming to enhance interaction with a Jupyter notebook using AI for improved productivity and dynamic task execution.\\\', part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 39, tzinfo=datetime.timezone.utc), kind=\\\'response\\\')]\']}, \'execution_count\': 23, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[37]:\nSource:\n#| export\n@notebook_agent.tool\ndef modify_cell(ctx: RunContext[str], cell_index: int, content: str) -&gt; str:\n    """Modify an existing cell in the notebook.\n    \n    Args:\n        cell_index: The index of the cell to modify\n        content: The new content for the cell\n        \n    Returns:\n        A confirmation message\n    """\n    try:\n        notebook = find_current_notebook()\n        if not notebook:\n            return "Error: Could not find current notebook"\n            \n        cells = notebook[\'cells\']\n        if cell_index &lt; 0 or cell_index &gt;= len(cells):\n            return f"Error: Cell index {cell_index} is out of range"\n            \n        # Get the cell\n        cell = cells[cell_index]\n        \n        # Update the cell content in IPython\n        ipython = get_ipython()\n        if not ipython:\n            return "Error: Not running in IPython environment"\n            \n        # Set the content of the specified cell\n        ipython.set_next_input(content, replace=True)\n        \n        return f"Modified cell {cell_index} with new content"\n        \n    except Exception as e:\n        return f"Error modifying cell: {str(e)}"\nOutputs:\n[{\'name\': \'stderr\', \'output_type\': \'stream\', \'text\': [\'&lt;module&gt;:8: No type or annotation for returned value 1\\n\']}, {\'ename\': \'UserError\', \'evalue\': "Tool name conflicts with existing tool: \'modify_cell\'", \'output_type\': \'error\', \'traceback\': [\'\\x1b[0;31m---------------------------------------------------------------------------\\x1b[0m\', \'\\x1b[0;31mUserError\\x1b[0m                                 Traceback (most recent call last)\', \'Cell \\x1b[0;32mIn[42], line 2\\x1b[0m\\n\\x1b[1;32m      1\\x1b[0m \\x1b[38;5;66;03m#| export\\x1b[39;00m\\n\\x1b[0;32m----&gt; 2\\x1b[0m \\x1b[38;5;129;43m@notebook_agent\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43mtool\\x1b[49m\\n\\x1b[1;32m      3\\x1b[0m \\x1b[38;5;28;43;01mdef\\x1b[39;49;00m\\x1b[43m \\x1b[49m\\x1b[38;5;21;43mmodify_cell\\x1b[39;49m\\x1b[43m(\\x1b[49m\\x1b[43mctx\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mRunContext\\x1b[49m\\x1b[43m[\\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m]\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mcell_index\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mint\\x1b[39;49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mcontent\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m)\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;241;43m-\\x1b[39;49m\\x1b[38;5;241;43m&gt;\\x1b[39;49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m:\\x1b[49m\\n\\x1b[1;32m      4\\x1b[0m \\x1b[38;5;250;43m    \\x1b[39;49m\\x1b[38;5;124;43;03m"""Modify an existing cell in the notebook.\\x1b[39;49;00m\\n\\x1b[1;32m      5\\x1b[0m \\x1b[38;5;124;43;03m    \\x1b[39;49;00m\\n\\x1b[1;32m      6\\x1b[0m \\x1b[38;5;124;43;03m    Args:\\x1b[39;49;00m\\n\\x1b[0;32m   (...)\\x1b[0m\\n\\x1b[1;32m     11\\x1b[0m \\x1b[38;5;124;43;03m        A confirmation message\\x1b[39;49;00m\\n\\x1b[1;32m     12\\x1b[0m \\x1b[38;5;124;43;03m    """\\x1b[39;49;00m\\n\\x1b[1;32m     13\\x1b[0m \\x1b[43m    \\x1b[49m\\x1b[38;5;28;43;01mtry\\x1b[39;49;00m\\x1b[43m:\\x1b[49m\\n\', \'File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:683\\x1b[0m, in \\x1b[0;36mAgent.tool\\x1b[0;34m(self, func, retries, prepare)\\x1b[0m\\n\\x1b[1;32m    680\\x1b[0m     \\x1b[38;5;28;01mreturn\\x1b[39;00m tool_decorator\\n\\x1b[1;32m    681\\x1b[0m \\x1b[38;5;28;01melse\\x1b[39;00m:\\n\\x1b[1;32m    682\\x1b[0m     \\x1b[38;5;66;03m# noinspection PyTypeChecker\\x1b[39;00m\\n\\x1b[0;32m--&gt; 683\\x1b[0m     \\x1b[38;5;28;43mself\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43m_register_function\\x1b[49m\\x1b[43m(\\x1b[49m\\x1b[43mfunc\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43;01mTrue\\x1b[39;49;00m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mretries\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mprepare\\x1b[49m\\x1b[43m)\\x1b[49m\\n\\x1b[1;32m    684\\x1b[0m     \\x1b[38;5;28;01mreturn\\x1b[39;00m func\\n\', \'File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:765\\x1b[0m, in \\x1b[0;36mAgent._register_function\\x1b[0;34m(self, func, takes_ctx, retries, prepare)\\x1b[0m\\n\\x1b[1;32m    763\\x1b[0m retries_ \\x1b[38;5;241m=\\x1b[39m retries \\x1b[38;5;28;01mif\\x1b[39;00m retries \\x1b[38;5;129;01mis\\x1b[39;00m \\x1b[38;5;129;01mnot\\x1b[39;00m \\x1b[38;5;28;01mNone\\x1b[39;00m \\x1b[38;5;28;01melse\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_default_retries\\n\\x1b[1;32m    764\\x1b[0m tool \\x1b[38;5;241m=\\x1b[39m Tool(func, takes_ctx\\x1b[38;5;241m=\\x1b[39mtakes_ctx, max_retries\\x1b[38;5;241m=\\x1b[39mretries_, prepare\\x1b[38;5;241m=\\x1b[39mprepare)\\n\\x1b[0;32m--&gt; 765\\x1b[0m \\x1b[38;5;28;43mself\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43m_register_tool\\x1b[49m\\x1b[43m(\\x1b[49m\\x1b[43mtool\\x1b[49m\\x1b[43m)\\x1b[49m\\n\', "File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:774\\x1b[0m, in \\x1b[0;36mAgent._register_tool\\x1b[0;34m(self, tool)\\x1b[0m\\n\\x1b[1;32m    771\\x1b[0m     tool \\x1b[38;5;241m=\\x1b[39m dataclasses\\x1b[38;5;241m.\\x1b[39mreplace(tool, max_retries\\x1b[38;5;241m=\\x1b[39m\\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_default_retries)\\n\\x1b[1;32m    773\\x1b[0m \\x1b[38;5;28;01mif\\x1b[39;00m tool\\x1b[38;5;241m.\\x1b[39mname \\x1b[38;5;129;01min\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_function_tools:\\n\\x1b[0;32m--&gt; 774\\x1b[0m     \\x1b[38;5;28;01mraise\\x1b[39;00m exceptions\\x1b[38;5;241m.\\x1b[39mUserError(\\x1b[38;5;124mf\\x1b[39m\\x1b[38;5;124m\'\\x1b[39m\\x1b[38;5;124mTool name conflicts with existing tool: \\x1b[39m\\x1b[38;5;132;01m{\\x1b[39;00mtool\\x1b[38;5;241m.\\x1b[39mname\\x1b[38;5;132;01m!r}\\x1b[39;00m\\x1b[38;5;124m\'\\x1b[39m)\\n\\x1b[1;32m    776\\x1b[0m \\x1b[38;5;28;01mif\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_result_schema \\x1b[38;5;129;01mand\\x1b[39;00m tool\\x1b[38;5;241m.\\x1b[39mname \\x1b[38;5;129;01min\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_result_schema\\x1b[38;5;241m.\\x1b[39mtools:\\n\\x1b[1;32m    777\\x1b[0m     \\x1b[38;5;28;01mraise\\x1b[39;00m exceptions\\x1b[38;5;241m.\\x1b[39mUserError(\\x1b[38;5;124mf\\x1b[39m\\x1b[38;5;124m\'\\x1b[39m\\x1b[38;5;124mTool name conflicts with result schema name: \\x1b[39m\\x1b[38;5;132;01m{\\x1b[39;00mtool\\x1b[38;5;241m.\\x1b[39mname\\x1b[38;5;132;01m!r}\\x1b[39;00m\\x1b[38;5;124m\'\\x1b[39m)\\n", "\\x1b[0;31mUserError\\x1b[0m: Tool name conflicts with existing tool: \'modify_cell\'"]}]\n\nCell[38]:\nSource:\n\nOutputs:\n[]\n\nCell[39]:\nSource:\n### Creating prompt cell magic\nOutputs:\nNone\n\nCell[40]:\nSource:\n#| export\nfrom IPython.core.magic import register_cell_magic\n\n#| export\n@register_cell_magic\ndef prompt(line, cell):\n    """Cell magic to create prompt cells that interact with the AI agent."""\n    try:\n        # Get the last result\'s message history if it exists\n        message_history = None\n        if \'last_prompt_result\' in get_ipython().user_ns:\n            last_result = get_ipython().user_ns[\'last_prompt_result\']\n            if hasattr(last_result, \'all_messages\'):\n                message_history = last_result.all_messages()\n        \n        # Use get_current_agent() instead of notebook_agent directly\n        agent = get_current_agent()\n        \n        # Run the prompt through our agent with history context\n        result = run_with_history(\n            agent, \n            cell.strip(), \n            message_history=message_history\n        )\n        \n        # Store the result for next time\n        get_ipython().user_ns[\'last_prompt_result\'] = result\n        \n        return Markdown(result.data)\n    except Exception as e:\n        return f"Error processing prompt: {str(e)}"\nOutputs:\n[]', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436565, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content='I understand the new notebook context. How can I help?', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436588, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[UserPromptPart(content='what this notebook is all about?', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436914, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content='This notebook appears to be part of a system that uses an AI agent to automate tasks within a Jupyter notebook. Here are some key points:\n\n1. **AI Agent Integration**: The notebook is integrating a Pydantic AI model, specifically an agent that seems to respond to prompts and perform tasks within the notebook environment.\n\n2. **Function Definitions**: Several Python functions have been defined:\n   - `factorial()`: This function calculates the factorial of a number with input validation.\n   - `hello_world()`: A simple function that prints "Hello, World!".\n\n3. **Cell Creation and Management**: There are functions and tools implemented to create and manage notebook cells programmatically. For example, the `create_cell` function uses the IPython\'s API to insert new cells.\n\n4. **Notebook History Management**: The notebook implements functionality to keep track of the history of executed notebook cells, which can be used to provide context to the AI agent.\n\n5. **History-Aware Prompts**: Functions like `create_history_aware_prompt` are used to create prompts that include historical context from the notebook. This allows the AI to make more informed decisions by understanding previous interactions and code.\n\n6. **Testing and Execution**: The notebook includes cells dedicated to testing these features, like running the agent with notebook history and testing the factorial function.\n\nOverall, it seems to be an experimental setup aiming to enhance interaction with a Jupyter notebook using AI for improved productivity and dynamic task execution.', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 11, 33, tzinfo=datetime.timezone.utc), kind='response')]</code></pre>
</div>
</div>
<div id="cell-36" class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> last_prompt_result_data():</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> last_prompt_result.data</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>last_prompt_result_data()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>'This notebook appears to be part of a system that uses an AI agent to automate tasks within a Jupyter notebook. Here are some key points:\n\n1. **AI Agent Integration**: The notebook is integrating a Pydantic AI model, specifically an agent that seems to respond to prompts and perform tasks within the notebook environment.\n\n2. **Function Definitions**: Several Python functions have been defined:\n   - `factorial()`: This function calculates the factorial of a number with input validation.\n   - `hello_world()`: A simple function that prints "Hello, World!".\n\n3. **Cell Creation and Management**: There are functions and tools implemented to create and manage notebook cells programmatically. For example, the `create_cell` function uses the IPython\'s API to insert new cells.\n\n4. **Notebook History Management**: The notebook implements functionality to keep track of the history of executed notebook cells, which can be used to provide context to the AI agent.\n\n5. **History-Aware Prompts**: Functions like `create_history_aware_prompt` are used to create prompts that include historical context from the notebook. This allows the AI to make more informed decisions by understanding previous interactions and code.\n\n6. **Testing and Execution**: The notebook includes cells dedicated to testing these features, like running the agent with notebook history and testing the factorial function.\n\nOverall, it seems to be an experimental setup aiming to enhance interaction with a Jupyter notebook using AI for improved productivity and dynamic task execution.'</code></pre>
</div>
</div>
<div id="cell-37" class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> all_messages():</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> last_prompt_result.all_messages()</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>all_messages()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>[ModelRequest(parts=[UserPromptPart(content='Here is the context of new notebook cells that were added:\nCell[36]:\nSource:\nresult.all_messages()\nOutputs:\n[{\'data\': {\'text/plain\': [\'[ModelRequest(parts=[SystemPromptPart(content="\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\'s date is 2024-12-31.\\\\n", part_kind=\\\'system-prompt\\\'), UserPromptPart(content=\\\'Create a function that calculates the factorial of a number with input validation\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 28, 691513, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', \' ModelResponse(parts=[ToolCallPart(tool_name=\\\'create_cell\\\', args=ArgsJson(args_json=\\\'{"content":"def factorial(n):\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\\\\\n    :param n: non-negative integer\\\\\\\\n    :return: factorial of n\\\\\\\\n    :raises ValueError: if n is not a non-negative integer\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    if not isinstance(n, int):\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be an integer\\\\\\\\")\\\\\\\\n    if n &lt; 0:\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be a non-negative integer\\\\\\\\")\\\\\\\\n    if n == 0 or n == 1:\\\\\\\\n        return 1\\\\\\\\n    result = 1\\\\\\\\n    for i in range(2, n + 1):\\\\\\\\n        result *= i\\\\\\\\n    return result","cell_type":"code"}\\\'), tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', part_kind=\\\'tool-call\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 29, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[ToolReturnPart(tool_name=\\\'create_cell\\\', content=\\\'Created new code  with content: def factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\n    :param n: non-negative integer\\\\n    :return: factorial of n\\\\n    :raises ValueError: if n is not a non-negative integer\\\\n    """\\\\n    if not isinstance(n, int):\\\\n        raise ValueError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n    if n == 0 or n == 1:\\\\n        return 1\\\\n    result = 1\\\\n    for i in range(2, n + 1):\\\\n        result *= i\\\\n    return result\\\', tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 32, 646314, tzinfo=datetime.timezone.utc), part_kind=\\\'tool-return\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what you just made for me here?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, 948002, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\\\n\\\\nHere\\\'s a summary of what the function does:\\\\n- It checks if the input is an integer. If not, it raises a `ValueError`.\\\\n- It checks if the input is a non-negative integer. If it\\\'s negative, it raises a `ValueError`.\\\\n- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\\\n- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.", part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 34, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[UserPromptPart(content=\\\'Here is the context of new notebook cells that were added:\\\\nCell[13]:\\\\nSource:\\\\nTool testing\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[14]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\')\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': [\\\\\\\'I\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 7, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[15]:\\\\nSource:\\\\ndef hello_world():\\\\n    print(\\\\\\\'Hello, World!\\\\\\\')\\\\n\\\\n# Call the function to display the output\\\\nhello_world()\\\\nOutputs:\\\\n[{\\\\\\\'name\\\\\\\': \\\\\\\'stdout\\\\\\\', \\\\\\\'output_type\\\\\\\': \\\\\\\'stream\\\\\\\', \\\\\\\'text\\\\\\\': [\\\\\\\'Hello, World!\\\\\\\\n\\\\\\\']}]\\\\n\\\\nCell[16]:\\\\nSource:\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\'s environment."], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 9, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[17]:\\\\nSource:\\\\ndef factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n.\\\\n\\\\n    Parameters:\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\n\\\\n    Returns:\\\\n    int: Factorial of the input number n\\\\n    """\\\\n    # Input validation\\\\n    if not isinstance(n, int):\\\\n        raise TypeError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n\\\\n    # Base case: factorial of 0 is 1\\\\n    if n == 0:\\\\n        return 1\\\\n\\\\n    # Recursive case: n! = n * (n-1)!\\\\n    return n * factorial(n - 1)\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[18]:\\\\nSource:\\\\nTesting agent with history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[19]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'So what you just made for me here?\\\\\\\', message_history=result.new_messages())\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\'s a brief overview of its features:\\\\\\\\n", \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\n\\\\\\\', \\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\).\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'```python\\\\\\\\n\\\\\\\', \\\\\\\'factorial(5)\\\\\\\\n\\\\\\\', \\\\\\\'```\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 11, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[20]:\\\\nSource:\\\\nresult.all_messages()\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': [\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\')]\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 12, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[21]:\\\\nSource:\\\\n### Adding notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[22]:\\\\nSource:\\\\n#| export\\\\nimport os\\\\nimport json\\\\nfrom pathlib import Path\\\\nfrom typing import Optional, Dict, Any\\\\n\\\\n# Cache for notebook data\\\\n_notebook_cache: Dict[str, Any] = {}\\\\n\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\n    """Find and cache the current notebook data.\\\\n    \\\\n    Returns:\\\\n        Dict containing notebook data or None if not found\\\\n    """\\\\n    global _notebook_cache\\\\n    \\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return None\\\\n            \\\\n        # Get current cell content to identify the notebook\\\\n        current_cell = ipython.get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        \\\\n        # Check if we already found the notebook\\\\n        if \\\\\\\'notebook\\\\\\\' in _notebook_cache:\\\\n            # Verify it\\\\\\\'s still the correct notebook by checking the current cell\\\\n            notebook = _notebook_cache[\\\\\\\'notebook\\\\\\\']\\\\n            for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                    \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                    return notebook\\\\n        \\\\n        # If not in cache or cache is invalid, search for the notebook\\\\n        current_dir = Path.cwd()\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\n        \\\\n        for nb_file in notebook_files:\\\\n            try:\\\\n                with open(nb_file) as f:\\\\n                    notebook = json.load(f)\\\\n                    for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                        if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                            \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                            # Found the notebook, cache it\\\\n                            _notebook_cache[\\\\\\\'notebook\\\\\\\'] = notebook\\\\n                            _notebook_cache[\\\\\\\'file\\\\\\\'] = nb_file\\\\n                            return notebook\\\\n            except Exception:\\\\n                continue\\\\n                \\\\n        return None\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error finding notebook: {e}")\\\\n        return None\\\\n\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[23]:\\\\nSource:\\\\n#| export\\\\nmax_lookback = 10\\\\n\\\\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\n    \\\\n    Args:\\\\n        max_cells: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        List of previous cell contents\\\\n    """\\\\n    try:\\\\n        # Get the cached notebook or find it\\\\n        notebook = find_current_notebook()\\\\n        if not notebook:\\\\n            return []\\\\n            \\\\n        # Find current cell index\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        cells = notebook[\\\\\\\'cells\\\\\\\']\\\\n        current_idx = -1\\\\n        last_prompt_idx = -1\\\\n        \\\\n        # Find current cell and last prompt cell\\\\n        for idx, cell in enumerate(cells):\\\\n            source = \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) if isinstance(cell[\\\\\\\'source\\\\\\\'], list) else cell[\\\\\\\'source\\\\\\\']\\\\n            \\\\n            # Find current cell\\\\n            if current_idx == -1 and cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source == current_cell:\\\\n                current_idx = idx\\\\n                \\\\n            # Find last prompt cell before current cell\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\n                if cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source.strip().startswith(\\\\\\\'%%prompt\\\\\\\'):\\\\n                    last_prompt_idx = idx\\\\n                \\\\n        if current_idx == -1:\\\\n            return []\\\\n            \\\\n        # Get cells between last prompt and current cell\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\n        history = []\\\\n        \\\\n        for idx in range(start_idx, current_idx):\\\\n            cell = cells[idx]            \\\\n            source = cell[\\\\\\\'source\\\\\\\'] if isinstance(cell[\\\\\\\'source\\\\\\\'], str) else \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\'])\\\\n            if \\\\\\\'outputs\\\\\\\' in cell:\\\\n                outputs = cell[\\\\\\\'outputs\\\\\\\'] if isinstance(cell[\\\\\\\'outputs\\\\\\\'], str) else str(cell[\\\\\\\'outputs\\\\\\\'])\\\\n            else:\\\\n                outputs = \\\\\\\'None\\\\\\\'\\\\n            if not (source.strip().startswith(\\\\\\\'%%prompt\\\\\\\') or outputs.strip().startswith(\\\\\\\'#|exclude\\\\\\\') or outputs.strip().startswith(\\\\\\\'#| exclude\\\\\\\')):\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\nSource:\\\\\\\\n{source}\\\\\\\\nOutputs:\\\\\\\\n{outputs}")\\\\n        \\\\n        return history\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error getting notebook history: {e}")\\\\n        return []\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[24]:\\\\nSource:\\\\nTesting notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[25]:\\\\nSource:\\\\nnb_hist = get_notebook_history(max_cells=20)\\\\nnb_hist\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': ["[\\\\\\\'Cell[3]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nfrom dotenv import load_dotenv\\\\\\\\\\\\\\\\nfrom pydantic import BaseModel, Field\\\\\\\\\\\\\\\\nfrom pydantic_ai import Agent, ModelRetry, RunContext\\\\\\\\\\\\\\\\nfrom pydantic_ai.models import KnownModelName\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nload_dotenv()\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Enable async/await in Jupyter\\\\\\\\\\\\\\\\nimport nest_asyncio\\\\\\\\\\\\\\\\nnest_asyncio.apply()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[4]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n# Agent setup\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[5]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nSystem prompt\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[6]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom datetime import date\\\\\\\\\\\\\\\\nsystem_prompt = f"""\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is {date.today().strftime(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%Y-%m-%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')}.\\\\\\\\\\\\\\\\n"""\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' "Cell[7]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\']}]",\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[8]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[9]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding cell creation tool\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[10]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stderr\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;module&gt;:8: No type or annotation for returned value 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[11]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTool testing\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[12]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 7, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' "Cell[13]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\nhello_world()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\']}]",\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[14]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment."], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 9, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[15]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef factorial(n):\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\n        raise TypeError("Input must be an integer")\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer")\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[16]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting agent with history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[17]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'factorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 11, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[18]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Created new code cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-return\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 12, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[19]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[20]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[21]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\n            cell = cells[idx]            \\\\\\\\\\\\\\\\n            source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            outputs = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            if not (source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#|exclude\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')):\\\\\\\\\\\\\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{outputs}")\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[22]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\']"]}, \\\\\\\'execution_count\\\\\\\': 28, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[26]:\\\\nSource:\\\\n### Creating history-aware prompt\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[27]:\\\\nSource:\\\\n#| export\\\\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\\\\n    """Create a prompt with notebook history context and message history.\\\\n    \\\\n    Args:\\\\n        prompt: The user\\\\\\\'s prompt\\\\n        message_history: Previous conversation messages from results.all_messages()\\\\n        max_history: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        Tuple of (enhanced prompt, combined message history)\\\\n    """\\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return prompt, message_history\\\\n        \\\\n        # Get new cells using our optimized get_notebook_history\\\\n        new_cells = get_notebook_history(max_cells=max_history)\\\\n        \\\\n        if not new_cells and not message_history:\\\\n            return prompt, None\\\\n            \\\\n        # Create message history if none exists\\\\n        from pydantic_ai.messages import (\\\\n            ModelRequest, ModelResponse, \\\\n            UserPromptPart, TextPart\\\\n        )\\\\n        \\\\n        messages = []\\\\n        \\\\n        # Add existing message history if provided\\\\n        if message_history:\\\\n            messages.extend(message_history)\\\\n        \\\\n        # Only add context message if we have new cells\\\\n        if new_cells:\\\\n            # Create context message with new cells\\\\n            history_content = "\\\\\\\\n\\\\\\\\n".join(new_cells)\\\\n\\\\n            context_msg = ModelRequest(parts=[\\\\n                UserPromptPart(\\\\n                    content="Here is the context of new notebook cells that were added:\\\\\\\\n" + history_content\\\\n                )\\\\n            ])\\\\n            \\\\n            # Create response acknowledging new context\\\\n            context_response = ModelResponse(parts=[\\\\n                TextPart(\\\\n                    content="I understand the new notebook context. How can I help?"\\\\n                )\\\\n            ])\\\\n            \\\\n            messages.extend([context_msg, context_response])\\\\n                \\\\n        return prompt, messages\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error creating history-aware prompt: {e}")\\\\n        return prompt, message_history\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[28]:\\\\nSource:\\\\nTesting history-aware prompt\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[29]:\\\\nSource:\\\\ncreate_history_aware_prompt(\\\\\\\'So what you just made for me here?\\\\\\\', result.all_messages(), max_history=20)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': ["(\\\\\\\'So what you just made for me here?\\\\\\\',\\\\\\\\n", \\\\\\\' [ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\'  ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\'  ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\'  ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\'  ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\'Here is the context of new notebook cells that were added:\\\\\\\\\\\\\\\\nCell[7]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[8]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[9]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding cell creation tool\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[10]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stderr\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;module&gt;:8: No type or annotation for returned value 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[11]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTool testing\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[12]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 7, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[13]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\nhello_world()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[14]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment."], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 9, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[15]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef factorial(n):\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\n        raise TypeError("Input must be an integer")\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer")\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[16]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting agent with history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[17]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'factorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 11, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[18]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Created new code cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-return\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 12, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[19]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[20]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[21]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\n            cell = cells[idx]            \\\\\\\\\\\\\\\\n            source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            outputs = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            if not (source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#|exclude\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')):\\\\\\\\\\\\\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{outputs}")\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[22]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[23]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nnb_hist = get_notebook_history(max_cells=20)\\\\\\\\\\\\\\\\nnb_hist\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[0]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| default_exp core\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[1]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| hide\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom nbdev.showdoc import *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[2]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom dotenv import load_dotenv\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic import BaseModel, Field\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic_ai import Agent, ModelRetry, RunContext\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic_ai.models import KnownModelName\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nload_dotenv()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Enable async/await in Jupyter\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport nest_asyncio\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnest_asyncio.apply()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[3]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom datetime import date\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nsystem_prompt = f"""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is {date.today().strftime(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%Y-%m-%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')}.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n"""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[4]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[5]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[6]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[7]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[8]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nhello_world()",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[9]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[10]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef factorial(number):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation to check if the number is a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(number, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError("Input must be an integer.")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if number &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer.")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 or 1 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if number == 0 or number == 1:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return number * factorial(number - 1)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Example usage\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(factorial(5))  # Output: 120\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(factorial(0))  # Output: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Uncomment the following lines to test input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# print(factorial(-1))  # Should raise ValueError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# print(factorial(3.5))  # Should raise ValueError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[11]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[12]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[13]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[14]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            cell = cells[idx]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':  # Only include code cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                # Skip cells that are prompt cells and nbdev directives\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if not source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 58, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[24]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Creating history-aware prompt\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[25]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\\\\\\\\\\\\\\\\n    """Create a prompt with notebook history context and message history.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        prompt: The user\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s prompt\\\\\\\\\\\\\\\\n        message_history: Previous conversation messages from results.all_messages()\\\\\\\\\\\\\\\\n        max_history: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Tuple of (enhanced prompt, combined message history)\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return prompt, message_history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Get new cells using our optimized get_notebook_history\\\\\\\\\\\\\\\\n        new_cells = get_notebook_history(max_cells=max_history)\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        if not new_cells and not message_history:\\\\\\\\\\\\\\\\n            return prompt, None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Create message history if none exists\\\\\\\\\\\\\\\\n        from pydantic_ai.messages import (\\\\\\\\\\\\\\\\n            ModelRequest, ModelResponse, \\\\\\\\\\\\\\\\n            UserPromptPart, TextPart\\\\\\\\\\\\\\\\n        )\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        messages = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Add existing message history if provided\\\\\\\\\\\\\\\\n        if message_history:\\\\\\\\\\\\\\\\n            messages.extend(message_history)\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Only add context message if we have new cells\\\\\\\\\\\\\\\\n        if new_cells:\\\\\\\\\\\\\\\\n            # Create context message with new cells\\\\\\\\\\\\\\\\n            history_content = "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n".join(new_cells)\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n            context_msg = ModelRequest(parts=[\\\\\\\\\\\\\\\\n                UserPromptPart(\\\\\\\\\\\\\\\\n                    content="Here is the context of new notebook cells that were added:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n" + history_content\\\\\\\\\\\\\\\\n                )\\\\\\\\\\\\\\\\n            ])\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Create response acknowledging new context\\\\\\\\\\\\\\\\n            context_response = ModelResponse(parts=[\\\\\\\\\\\\\\\\n                TextPart(\\\\\\\\\\\\\\\\n                    content="I understand the new notebook context. How can I help?"\\\\\\\\\\\\\\\\n                )\\\\\\\\\\\\\\\\n            ])\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            messages.extend([context_msg, context_response])\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return prompt, messages\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error creating history-aware prompt: {e}")\\\\\\\\\\\\\\\\n        return prompt, message_history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[26]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting history-aware prompt\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 26, 5, 737496, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelResponse(parts=[TextPart(content=\\\\\\\'I understand the new notebook context. How can I help?\\\\\\\', part_kind=\\\\\\\'text\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 26, 5, 737510, tzinfo=datetime.timezone.utc), kind=\\\\\\\'response\\\\\\\')])"]}, \\\\\\\'execution_count\\\\\\\': 30, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[30]:\\\\nSource:\\\\n### Running agent with notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[31]:\\\\nSource:\\\\n#| export\\\\nfrom typing import Any\\\\ndef run_with_history(agent: Agent, prompt: str, message_history: list = None, max_history: int = 5) -&gt; Any:\\\\n    """Run the agent with notebook and conversation history context.\\\\n    \\\\n    Args:\\\\n        agent: The PydanticAI agent\\\\n        prompt: The user\\\\\\\'s prompt\\\\n        message_history: Previous conversation messages\\\\n        max_history: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        Agent run result\\\\n    """\\\\n    prompt, combined_history = create_history_aware_prompt(\\\\n        prompt, \\\\n        message_history=message_history, \\\\n        max_history=max_history\\\\n    )\\\\n    return agent.run_sync(prompt, message_history=combined_history)\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[32]:\\\\nSource:\\\\nTesting run_with_history\\\\nOutputs:\\\\nNone\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976699, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I understand the new notebook context. How can I help?\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976722, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what is going on in this notebook?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976975, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content=\\\'This notebook appears to be part of a system that uses an AI agent to automate tasks within a Jupyter notebook. Here are some key points:\\\\n\\\\n1. **AI Agent Integration**: The notebook is integrating a Pydantic AI model, specifically an agent that seems to respond to prompts and perform tasks within the notebook environment.\\\\n\\\\n2. **Function Definitions**: Several Python functions have been defined:\\\\n   - `factorial()`: This function calculates the factorial of a number with input validation.\\\\n   - `hello_world()`: A simple function that prints "Hello, World!".\\\\n   \\\\n3. **Cell Creation and Management**: There are functions and tools implemented to create and manage notebook cells programmatically. For example, the `create_cell` function uses the IPython\\\\\\\'s API to insert new cells.\\\\n\\\\n4. **Notebook History Management**: The notebook implements functionality to keep track of the history of executed notebook cells, which can be used to provide context to the AI agent.\\\\n\\\\n5. **History-Aware Prompts**: Functions like `create_history_aware_prompt` are used to create prompts that include historical context from the notebook. This allows the AI to make more informed decisions by understanding previous interactions and code.\\\\n\\\\n6. **Testing and Execution**: The notebook includes cells dedicated to testing these features, like running the agent with notebook history and testing the factorial function.\\\\n\\\\nOverall, it seems to be an experimental setup aiming to enhance interaction with a Jupyter notebook using AI for improved productivity and dynamic task execution.\\\', part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 39, tzinfo=datetime.timezone.utc), kind=\\\'response\\\')]\']}, \'execution_count\': 23, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[37]:\nSource:\n#| export\n@notebook_agent.tool\ndef modify_cell(ctx: RunContext[str], cell_index: int, content: str) -&gt; str:\n    """Modify an existing cell in the notebook.\n    \n    Args:\n        cell_index: The index of the cell to modify\n        content: The new content for the cell\n        \n    Returns:\n        A confirmation message\n    """\n    try:\n        notebook = find_current_notebook()\n        if not notebook:\n            return "Error: Could not find current notebook"\n            \n        cells = notebook[\'cells\']\n        if cell_index &lt; 0 or cell_index &gt;= len(cells):\n            return f"Error: Cell index {cell_index} is out of range"\n            \n        # Get the cell\n        cell = cells[cell_index]\n        \n        # Update the cell content in IPython\n        ipython = get_ipython()\n        if not ipython:\n            return "Error: Not running in IPython environment"\n            \n        # Set the content of the specified cell\n        ipython.set_next_input(content, replace=True)\n        \n        return f"Modified cell {cell_index} with new content"\n        \n    except Exception as e:\n        return f"Error modifying cell: {str(e)}"\nOutputs:\n[{\'name\': \'stderr\', \'output_type\': \'stream\', \'text\': [\'&lt;module&gt;:8: No type or annotation for returned value 1\\n\']}, {\'ename\': \'UserError\', \'evalue\': "Tool name conflicts with existing tool: \'modify_cell\'", \'output_type\': \'error\', \'traceback\': [\'\\x1b[0;31m---------------------------------------------------------------------------\\x1b[0m\', \'\\x1b[0;31mUserError\\x1b[0m                                 Traceback (most recent call last)\', \'Cell \\x1b[0;32mIn[42], line 2\\x1b[0m\\n\\x1b[1;32m      1\\x1b[0m \\x1b[38;5;66;03m#| export\\x1b[39;00m\\n\\x1b[0;32m----&gt; 2\\x1b[0m \\x1b[38;5;129;43m@notebook_agent\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43mtool\\x1b[49m\\n\\x1b[1;32m      3\\x1b[0m \\x1b[38;5;28;43;01mdef\\x1b[39;49;00m\\x1b[43m \\x1b[49m\\x1b[38;5;21;43mmodify_cell\\x1b[39;49m\\x1b[43m(\\x1b[49m\\x1b[43mctx\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mRunContext\\x1b[49m\\x1b[43m[\\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m]\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mcell_index\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mint\\x1b[39;49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mcontent\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m)\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;241;43m-\\x1b[39;49m\\x1b[38;5;241;43m&gt;\\x1b[39;49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m:\\x1b[49m\\n\\x1b[1;32m      4\\x1b[0m \\x1b[38;5;250;43m    \\x1b[39;49m\\x1b[38;5;124;43;03m"""Modify an existing cell in the notebook.\\x1b[39;49;00m\\n\\x1b[1;32m      5\\x1b[0m \\x1b[38;5;124;43;03m    \\x1b[39;49;00m\\n\\x1b[1;32m      6\\x1b[0m \\x1b[38;5;124;43;03m    Args:\\x1b[39;49;00m\\n\\x1b[0;32m   (...)\\x1b[0m\\n\\x1b[1;32m     11\\x1b[0m \\x1b[38;5;124;43;03m        A confirmation message\\x1b[39;49;00m\\n\\x1b[1;32m     12\\x1b[0m \\x1b[38;5;124;43;03m    """\\x1b[39;49;00m\\n\\x1b[1;32m     13\\x1b[0m \\x1b[43m    \\x1b[49m\\x1b[38;5;28;43;01mtry\\x1b[39;49;00m\\x1b[43m:\\x1b[49m\\n\', \'File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:683\\x1b[0m, in \\x1b[0;36mAgent.tool\\x1b[0;34m(self, func, retries, prepare)\\x1b[0m\\n\\x1b[1;32m    680\\x1b[0m     \\x1b[38;5;28;01mreturn\\x1b[39;00m tool_decorator\\n\\x1b[1;32m    681\\x1b[0m \\x1b[38;5;28;01melse\\x1b[39;00m:\\n\\x1b[1;32m    682\\x1b[0m     \\x1b[38;5;66;03m# noinspection PyTypeChecker\\x1b[39;00m\\n\\x1b[0;32m--&gt; 683\\x1b[0m     \\x1b[38;5;28;43mself\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43m_register_function\\x1b[49m\\x1b[43m(\\x1b[49m\\x1b[43mfunc\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43;01mTrue\\x1b[39;49;00m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mretries\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mprepare\\x1b[49m\\x1b[43m)\\x1b[49m\\n\\x1b[1;32m    684\\x1b[0m     \\x1b[38;5;28;01mreturn\\x1b[39;00m func\\n\', \'File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:765\\x1b[0m, in \\x1b[0;36mAgent._register_function\\x1b[0;34m(self, func, takes_ctx, retries, prepare)\\x1b[0m\\n\\x1b[1;32m    763\\x1b[0m retries_ \\x1b[38;5;241m=\\x1b[39m retries \\x1b[38;5;28;01mif\\x1b[39;00m retries \\x1b[38;5;129;01mis\\x1b[39;00m \\x1b[38;5;129;01mnot\\x1b[39;00m \\x1b[38;5;28;01mNone\\x1b[39;00m \\x1b[38;5;28;01melse\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_default_retries\\n\\x1b[1;32m    764\\x1b[0m tool \\x1b[38;5;241m=\\x1b[39m Tool(func, takes_ctx\\x1b[38;5;241m=\\x1b[39mtakes_ctx, max_retries\\x1b[38;5;241m=\\x1b[39mretries_, prepare\\x1b[38;5;241m=\\x1b[39mprepare)\\n\\x1b[0;32m--&gt; 765\\x1b[0m \\x1b[38;5;28;43mself\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43m_register_tool\\x1b[49m\\x1b[43m(\\x1b[49m\\x1b[43mtool\\x1b[49m\\x1b[43m)\\x1b[49m\\n\', "File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:774\\x1b[0m, in \\x1b[0;36mAgent._register_tool\\x1b[0;34m(self, tool)\\x1b[0m\\n\\x1b[1;32m    771\\x1b[0m     tool \\x1b[38;5;241m=\\x1b[39m dataclasses\\x1b[38;5;241m.\\x1b[39mreplace(tool, max_retries\\x1b[38;5;241m=\\x1b[39m\\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_default_retries)\\n\\x1b[1;32m    773\\x1b[0m \\x1b[38;5;28;01mif\\x1b[39;00m tool\\x1b[38;5;241m.\\x1b[39mname \\x1b[38;5;129;01min\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_function_tools:\\n\\x1b[0;32m--&gt; 774\\x1b[0m     \\x1b[38;5;28;01mraise\\x1b[39;00m exceptions\\x1b[38;5;241m.\\x1b[39mUserError(\\x1b[38;5;124mf\\x1b[39m\\x1b[38;5;124m\'\\x1b[39m\\x1b[38;5;124mTool name conflicts with existing tool: \\x1b[39m\\x1b[38;5;132;01m{\\x1b[39;00mtool\\x1b[38;5;241m.\\x1b[39mname\\x1b[38;5;132;01m!r}\\x1b[39;00m\\x1b[38;5;124m\'\\x1b[39m)\\n\\x1b[1;32m    776\\x1b[0m \\x1b[38;5;28;01mif\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_result_schema \\x1b[38;5;129;01mand\\x1b[39;00m tool\\x1b[38;5;241m.\\x1b[39mname \\x1b[38;5;129;01min\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_result_schema\\x1b[38;5;241m.\\x1b[39mtools:\\n\\x1b[1;32m    777\\x1b[0m     \\x1b[38;5;28;01mraise\\x1b[39;00m exceptions\\x1b[38;5;241m.\\x1b[39mUserError(\\x1b[38;5;124mf\\x1b[39m\\x1b[38;5;124m\'\\x1b[39m\\x1b[38;5;124mTool name conflicts with result schema name: \\x1b[39m\\x1b[38;5;132;01m{\\x1b[39;00mtool\\x1b[38;5;241m.\\x1b[39mname\\x1b[38;5;132;01m!r}\\x1b[39;00m\\x1b[38;5;124m\'\\x1b[39m)\\n", "\\x1b[0;31mUserError\\x1b[0m: Tool name conflicts with existing tool: \'modify_cell\'"]}]\n\nCell[38]:\nSource:\n\nOutputs:\n[]\n\nCell[39]:\nSource:\n### Creating prompt cell magic\nOutputs:\nNone\n\nCell[40]:\nSource:\n#| export\nfrom IPython.core.magic import register_cell_magic\n\n#| export\n@register_cell_magic\ndef prompt(line, cell):\n    """Cell magic to create prompt cells that interact with the AI agent."""\n    try:\n        # Get the last result\'s message history if it exists\n        message_history = None\n        if \'last_prompt_result\' in get_ipython().user_ns:\n            last_result = get_ipython().user_ns[\'last_prompt_result\']\n            if hasattr(last_result, \'all_messages\'):\n                message_history = last_result.all_messages()\n        \n        # Use get_current_agent() instead of notebook_agent directly\n        agent = get_current_agent()\n        \n        # Run the prompt through our agent with history context\n        result = run_with_history(\n            agent, \n            cell.strip(), \n            message_history=message_history\n        )\n        \n        # Store the result for next time\n        get_ipython().user_ns[\'last_prompt_result\'] = result\n        \n        return Markdown(result.data)\n    except Exception as e:\n        return f"Error processing prompt: {str(e)}"\nOutputs:\n[]', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436565, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content='I understand the new notebook context. How can I help?', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436588, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[UserPromptPart(content='what this notebook is all about?', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436914, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content='This notebook appears to be part of a system that uses an AI agent to automate tasks within a Jupyter notebook. Here are some key points:\n\n1. **AI Agent Integration**: The notebook is integrating a Pydantic AI model, specifically an agent that seems to respond to prompts and perform tasks within the notebook environment.\n\n2. **Function Definitions**: Several Python functions have been defined:\n   - `factorial()`: This function calculates the factorial of a number with input validation.\n   - `hello_world()`: A simple function that prints "Hello, World!".\n\n3. **Cell Creation and Management**: There are functions and tools implemented to create and manage notebook cells programmatically. For example, the `create_cell` function uses the IPython\'s API to insert new cells.\n\n4. **Notebook History Management**: The notebook implements functionality to keep track of the history of executed notebook cells, which can be used to provide context to the AI agent.\n\n5. **History-Aware Prompts**: Functions like `create_history_aware_prompt` are used to create prompts that include historical context from the notebook. This allows the AI to make more informed decisions by understanding previous interactions and code.\n\n6. **Testing and Execution**: The notebook includes cells dedicated to testing these features, like running the agent with notebook history and testing the factorial function.\n\nOverall, it seems to be an experimental setup aiming to enhance interaction with a Jupyter notebook using AI for improved productivity and dynamic task execution.', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 11, 33, tzinfo=datetime.timezone.utc), kind='response')]</code></pre>
</div>
</div>
<div id="cell-38" class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>tell me what have I added last to this notebook?</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>"Error processing prompt: Error code: 429 - {'error': {'message': 'Request too large for gpt-4o in organization org-Pm8WC2pvJDhMF1KkAgUCByZl on tokens per min (TPM): Limit 30000, Requested 62420. The input or output tokens must be reduced in order to run successfully. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}"</code></pre>
</div>
</div>
<div id="cell-39" class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>all_messages()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>[ModelRequest(parts=[UserPromptPart(content='Here is the context of new notebook cells that were added:\nCell[36]:\nSource:\nresult.all_messages()\nOutputs:\n[{\'data\': {\'text/plain\': [\'[ModelRequest(parts=[SystemPromptPart(content="\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\nYour regular text responses are rendered as cell output.\\\\nYou can create new cells, edit existing cells, and run code.\\\\nYou can also use tools to help you with your tasks.\\\\nToday\\\'s date is 2024-12-31.\\\\n", part_kind=\\\'system-prompt\\\'), UserPromptPart(content=\\\'Create a function that calculates the factorial of a number with input validation\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 28, 691513, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', \' ModelResponse(parts=[ToolCallPart(tool_name=\\\'create_cell\\\', args=ArgsJson(args_json=\\\'{"content":"def factorial(n):\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\\\\\n    :param n: non-negative integer\\\\\\\\n    :return: factorial of n\\\\\\\\n    :raises ValueError: if n is not a non-negative integer\\\\\\\\n    \\\\\\\\"\\\\\\\\"\\\\\\\\"\\\\\\\\n    if not isinstance(n, int):\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be an integer\\\\\\\\")\\\\\\\\n    if n &lt; 0:\\\\\\\\n        raise ValueError(\\\\\\\\"Input must be a non-negative integer\\\\\\\\")\\\\\\\\n    if n == 0 or n == 1:\\\\\\\\n        return 1\\\\\\\\n    result = 1\\\\\\\\n    for i in range(2, n + 1):\\\\\\\\n        result *= i\\\\\\\\n    return result","cell_type":"code"}\\\'), tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', part_kind=\\\'tool-call\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 29, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[ToolReturnPart(tool_name=\\\'create_cell\\\', content=\\\'Created new code  with content: def factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n with input validation.\\\\n    :param n: non-negative integer\\\\n    :return: factorial of n\\\\n    :raises ValueError: if n is not a non-negative integer\\\\n    """\\\\n    if not isinstance(n, int):\\\\n        raise ValueError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n    if n == 0 or n == 1:\\\\n        return 1\\\\n    result = 1\\\\n    for i in range(2, n + 1):\\\\n        result *= i\\\\n    return result\\\', tool_call_id=\\\'call_Iuc8vC4Y2axuMDvDh3TlF9mz\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 32, 646314, tzinfo=datetime.timezone.utc), part_kind=\\\'tool-return\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I have created a function to calculate the factorial of a number with input validation. You can test it by calling the `factorial` function with a non-negative integer as the argument.\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what you just made for me here?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 33, 948002, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content="I created a Python function named `factorial` that calculates the factorial of a non-negative integer. This function includes input validation to ensure that the input is a non-negative integer. If the input is not valid (i.e., not an integer or a negative integer), it raises a `ValueError`.\\\\n\\\\nHere\\\'s a summary of what the function does:\\\\n- It checks if the input is an integer. If not, it raises a `ValueError`.\\\\n- It checks if the input is a non-negative integer. If it\\\'s negative, it raises a `ValueError`.\\\\n- If the input is 0 or 1, it returns 1 (since 0! = 1! = 1).\\\\n- For other positive integers, it calculates the factorial by multiplying all integers from 2 up to the input number and returns the result.", part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 34, tzinfo=datetime.timezone.utc), kind=\\\'response\\\'),\\n\', \' ModelRequest(parts=[UserPromptPart(content=\\\'Here is the context of new notebook cells that were added:\\\\nCell[13]:\\\\nSource:\\\\nTool testing\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[14]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\')\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': [\\\\\\\'I\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 7, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[15]:\\\\nSource:\\\\ndef hello_world():\\\\n    print(\\\\\\\'Hello, World!\\\\\\\')\\\\n\\\\n# Call the function to display the output\\\\nhello_world()\\\\nOutputs:\\\\n[{\\\\\\\'name\\\\\\\': \\\\\\\'stdout\\\\\\\', \\\\\\\'output_type\\\\\\\': \\\\\\\'stream\\\\\\\', \\\\\\\'text\\\\\\\': [\\\\\\\'Hello, World!\\\\\\\\n\\\\\\\']}]\\\\n\\\\nCell[16]:\\\\nSource:\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\'s environment."], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 9, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[17]:\\\\nSource:\\\\ndef factorial(n):\\\\n    """\\\\n    Calculate the factorial of a non-negative integer n.\\\\n\\\\n    Parameters:\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\n\\\\n    Returns:\\\\n    int: Factorial of the input number n\\\\n    """\\\\n    # Input validation\\\\n    if not isinstance(n, int):\\\\n        raise TypeError("Input must be an integer")\\\\n    if n &lt; 0:\\\\n        raise ValueError("Input must be a non-negative integer")\\\\n\\\\n    # Base case: factorial of 0 is 1\\\\n    if n == 0:\\\\n        return 1\\\\n\\\\n    # Recursive case: n! = n * (n-1)!\\\\n    return n * factorial(n - 1)\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[18]:\\\\nSource:\\\\nTesting agent with history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[19]:\\\\nSource:\\\\nresult = notebook_agent.run_sync(\\\\\\\'So what you just made for me here?\\\\\\\', message_history=result.new_messages())\\\\nMarkdown(result.data)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/markdown\\\\\\\': ["I\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\'s a brief overview of its features:\\\\\\\\n", \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\n\\\\\\\', \\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\).\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'```python\\\\\\\\n\\\\\\\', \\\\\\\'factorial(5)\\\\\\\\n\\\\\\\', \\\\\\\'```\\\\\\\\n\\\\\\\', \\\\\\\'\\\\\\\\n\\\\\\\', \\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\'], \\\\\\\'text/plain\\\\\\\': [\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 11, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[20]:\\\\nSource:\\\\nresult.all_messages()\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': [\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\')]\\\\\\\']}, \\\\\\\'execution_count\\\\\\\': 12, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[21]:\\\\nSource:\\\\n### Adding notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[22]:\\\\nSource:\\\\n#| export\\\\nimport os\\\\nimport json\\\\nfrom pathlib import Path\\\\nfrom typing import Optional, Dict, Any\\\\n\\\\n# Cache for notebook data\\\\n_notebook_cache: Dict[str, Any] = {}\\\\n\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\n    """Find and cache the current notebook data.\\\\n    \\\\n    Returns:\\\\n        Dict containing notebook data or None if not found\\\\n    """\\\\n    global _notebook_cache\\\\n    \\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return None\\\\n            \\\\n        # Get current cell content to identify the notebook\\\\n        current_cell = ipython.get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        \\\\n        # Check if we already found the notebook\\\\n        if \\\\\\\'notebook\\\\\\\' in _notebook_cache:\\\\n            # Verify it\\\\\\\'s still the correct notebook by checking the current cell\\\\n            notebook = _notebook_cache[\\\\\\\'notebook\\\\\\\']\\\\n            for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                    \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                    return notebook\\\\n        \\\\n        # If not in cache or cache is invalid, search for the notebook\\\\n        current_dir = Path.cwd()\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\n        \\\\n        for nb_file in notebook_files:\\\\n            try:\\\\n                with open(nb_file) as f:\\\\n                    notebook = json.load(f)\\\\n                    for cell in notebook[\\\\\\\'cells\\\\\\\']:\\\\n                        if (cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and \\\\n                            \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) == current_cell):\\\\n                            # Found the notebook, cache it\\\\n                            _notebook_cache[\\\\\\\'notebook\\\\\\\'] = notebook\\\\n                            _notebook_cache[\\\\\\\'file\\\\\\\'] = nb_file\\\\n                            return notebook\\\\n            except Exception:\\\\n                continue\\\\n                \\\\n        return None\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error finding notebook: {e}")\\\\n        return None\\\\n\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[23]:\\\\nSource:\\\\n#| export\\\\nmax_lookback = 10\\\\n\\\\ndef get_notebook_history(max_cells: int = max_lookback) -&gt; list:\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\n    \\\\n    Args:\\\\n        max_cells: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        List of previous cell contents\\\\n    """\\\\n    try:\\\\n        # Get the cached notebook or find it\\\\n        notebook = find_current_notebook()\\\\n        if not notebook:\\\\n            return []\\\\n            \\\\n        # Find current cell index\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\'content\\\\\\\'][\\\\\\\'code\\\\\\\']\\\\n        cells = notebook[\\\\\\\'cells\\\\\\\']\\\\n        current_idx = -1\\\\n        last_prompt_idx = -1\\\\n        \\\\n        # Find current cell and last prompt cell\\\\n        for idx, cell in enumerate(cells):\\\\n            source = \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\']) if isinstance(cell[\\\\\\\'source\\\\\\\'], list) else cell[\\\\\\\'source\\\\\\\']\\\\n            \\\\n            # Find current cell\\\\n            if current_idx == -1 and cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source == current_cell:\\\\n                current_idx = idx\\\\n                \\\\n            # Find last prompt cell before current cell\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\n                if cell[\\\\\\\'cell_type\\\\\\\'] == \\\\\\\'code\\\\\\\' and source.strip().startswith(\\\\\\\'%%prompt\\\\\\\'):\\\\n                    last_prompt_idx = idx\\\\n                \\\\n        if current_idx == -1:\\\\n            return []\\\\n            \\\\n        # Get cells between last prompt and current cell\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\n        history = []\\\\n        \\\\n        for idx in range(start_idx, current_idx):\\\\n            cell = cells[idx]            \\\\n            source = cell[\\\\\\\'source\\\\\\\'] if isinstance(cell[\\\\\\\'source\\\\\\\'], str) else \\\\\\\'\\\\\\\'.join(cell[\\\\\\\'source\\\\\\\'])\\\\n            if \\\\\\\'outputs\\\\\\\' in cell:\\\\n                outputs = cell[\\\\\\\'outputs\\\\\\\'] if isinstance(cell[\\\\\\\'outputs\\\\\\\'], str) else str(cell[\\\\\\\'outputs\\\\\\\'])\\\\n            else:\\\\n                outputs = \\\\\\\'None\\\\\\\'\\\\n            if not (source.strip().startswith(\\\\\\\'%%prompt\\\\\\\') or outputs.strip().startswith(\\\\\\\'#|exclude\\\\\\\') or outputs.strip().startswith(\\\\\\\'#| exclude\\\\\\\')):\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\nSource:\\\\\\\\n{source}\\\\\\\\nOutputs:\\\\\\\\n{outputs}")\\\\n        \\\\n        return history\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error getting notebook history: {e}")\\\\n        return []\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[24]:\\\\nSource:\\\\nTesting notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[25]:\\\\nSource:\\\\nnb_hist = get_notebook_history(max_cells=20)\\\\nnb_hist\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': ["[\\\\\\\'Cell[3]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nfrom dotenv import load_dotenv\\\\\\\\\\\\\\\\nfrom pydantic import BaseModel, Field\\\\\\\\\\\\\\\\nfrom pydantic_ai import Agent, ModelRetry, RunContext\\\\\\\\\\\\\\\\nfrom pydantic_ai.models import KnownModelName\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nload_dotenv()\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Enable async/await in Jupyter\\\\\\\\\\\\\\\\nimport nest_asyncio\\\\\\\\\\\\\\\\nnest_asyncio.apply()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[4]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n# Agent setup\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[5]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nSystem prompt\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[6]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom datetime import date\\\\\\\\\\\\\\\\nsystem_prompt = f"""\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is {date.today().strftime(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%Y-%m-%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')}.\\\\\\\\\\\\\\\\n"""\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' "Cell[7]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\']}]",\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[8]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\',\\\\\\\\n", " \\\\\\\'Cell[9]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding cell creation tool\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[10]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stderr\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;module&gt;:8: No type or annotation for returned value 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[11]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTool testing\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[12]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 7, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' "Cell[13]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\nhello_world()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\']}]",\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[14]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment."], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 9, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[15]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef factorial(n):\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\n        raise TypeError("Input must be an integer")\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer")\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[16]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting agent with history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[17]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'factorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 11, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[18]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Created new code cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-return\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 12, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[19]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\',\\\\\\\\n", \\\\\\\' \\\\\\\\\\\\\\\'Cell[20]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', \\\\\\\' \\\\\\\\\\\\\\\'Cell[21]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\n            cell = cells[idx]            \\\\\\\\\\\\\\\\n            source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            outputs = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            if not (source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#|exclude\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')):\\\\\\\\\\\\\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{outputs}")\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\',\\\\\\\\n\\\\\\\', " \\\\\\\'Cell[22]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\']"]}, \\\\\\\'execution_count\\\\\\\': 28, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[26]:\\\\nSource:\\\\n### Creating history-aware prompt\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[27]:\\\\nSource:\\\\n#| export\\\\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\\\\n    """Create a prompt with notebook history context and message history.\\\\n    \\\\n    Args:\\\\n        prompt: The user\\\\\\\'s prompt\\\\n        message_history: Previous conversation messages from results.all_messages()\\\\n        max_history: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        Tuple of (enhanced prompt, combined message history)\\\\n    """\\\\n    try:\\\\n        ipython = get_ipython()\\\\n        if not ipython:\\\\n            return prompt, message_history\\\\n        \\\\n        # Get new cells using our optimized get_notebook_history\\\\n        new_cells = get_notebook_history(max_cells=max_history)\\\\n        \\\\n        if not new_cells and not message_history:\\\\n            return prompt, None\\\\n            \\\\n        # Create message history if none exists\\\\n        from pydantic_ai.messages import (\\\\n            ModelRequest, ModelResponse, \\\\n            UserPromptPart, TextPart\\\\n        )\\\\n        \\\\n        messages = []\\\\n        \\\\n        # Add existing message history if provided\\\\n        if message_history:\\\\n            messages.extend(message_history)\\\\n        \\\\n        # Only add context message if we have new cells\\\\n        if new_cells:\\\\n            # Create context message with new cells\\\\n            history_content = "\\\\\\\\n\\\\\\\\n".join(new_cells)\\\\n\\\\n            context_msg = ModelRequest(parts=[\\\\n                UserPromptPart(\\\\n                    content="Here is the context of new notebook cells that were added:\\\\\\\\n" + history_content\\\\n                )\\\\n            ])\\\\n            \\\\n            # Create response acknowledging new context\\\\n            context_response = ModelResponse(parts=[\\\\n                TextPart(\\\\n                    content="I understand the new notebook context. How can I help?"\\\\n                )\\\\n            ])\\\\n            \\\\n            messages.extend([context_msg, context_response])\\\\n                \\\\n        return prompt, messages\\\\n        \\\\n    except Exception as e:\\\\n        print(f"Error creating history-aware prompt: {e}")\\\\n        return prompt, message_history\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[28]:\\\\nSource:\\\\nTesting history-aware prompt\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[29]:\\\\nSource:\\\\ncreate_history_aware_prompt(\\\\\\\'So what you just made for me here?\\\\\\\', result.all_messages(), max_history=20)\\\\nOutputs:\\\\n[{\\\\\\\'data\\\\\\\': {\\\\\\\'text/plain\\\\\\\': ["(\\\\\\\'So what you just made for me here?\\\\\\\',\\\\\\\\n", \\\\\\\' [ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\'  ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\'create_cell\\\\\\\', content=\\\\\\\'Created new code cell\\\\\\\', tool_call_id=\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'tool-return\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\'  ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelRequest(parts=[UserPromptPart(content=\\\\\\\'So what you just made for me here?\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\'user-prompt\\\\\\\')], kind=\\\\\\\'request\\\\\\\'),\\\\\\\\n", \\\\\\\'  ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', \\\\\\\'  ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\'Here is the context of new notebook cells that were added:\\\\\\\\\\\\\\\\nCell[7]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[8]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[9]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding cell creation tool\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[10]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stderr\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;module&gt;:8: No type or annotation for returned value 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[11]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTool testing\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[12]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a new code cell with a simple "Hello, World!" function. You can run the cell to see the output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 7, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[13]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\nhello_world()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'name\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stdout\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'stream\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[14]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment."], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 9, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[15]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\ndef factorial(n):\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\n        raise TypeError("Input must be an integer")\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer")\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[16]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting agent with history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[17]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'To make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'factorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'This would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&lt;IPython.core.display.Markdown object&gt;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 11, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[18]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': [\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'[ModelRequest(parts=[SystemPromptPart(content="\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is 2024-12-31.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'system-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Create a function that calculates the factorial of a number with input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 34, 458473, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[ToolCallPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', args=ArgsJson(args_json=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'{"content":"def factorial(n):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Calculate the factorial of a non-negative integer n.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Parameters:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    n (int): A non-negative integer whose factorial is to be computed\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    int: Factorial of the input number n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(n, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise TypeError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be an integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Input must be a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if n == 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return n * factorial(n - 1)","cell_type":"code"}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-call\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 35, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[ToolReturnPart(tool_name=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'create_cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Created new code cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', tool_call_id=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'call_7ZMonXSp6BR3nTOGupyaiXdd\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, 114822, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'tool-return\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I have created a function named `factorial` in a new code cell. This function calculates the factorial of a number and includes input validation to ensure that the input is a non-negative integer. You can run that cell to define the function in the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s environment.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 37, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " ModelRequest(parts=[UserPromptPart(content=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 8, 58, 747643, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' ModelResponse(parts=[TextPart(content="I\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'ve created a Python function called `factorial` for you. This function calculates the factorial of a given non-negative integer. Here\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s a brief overview of its features:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Input Validation**: It checks whether the input is a non-negative integer. If the input is not an integer, it raises a `TypeError`. If the input is a negative integer, it raises a `ValueError`.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n- **Factorial Calculation**: It calculates the factorial using a recursive approach. The base case is that the factorial of 0 is 1, and for other numbers, it uses the recursive definition: \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\( n! = n \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\times (n-1)! \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\).\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTo make use of this function, you would call it with an integer argument, like so:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfactorial(5)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nThis would return `120`, which is the factorial of 5. You can test this function by running the code cell I created.", part_kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 8, 59, tzinfo=datetime.timezone.utc), kind=\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'response\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 12, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[19]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Adding notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[20]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[21]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\n            cell = cells[idx]            \\\\\\\\\\\\\\\\n            source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            outputs = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'outputs\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\n            if not (source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#|exclude\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') or outputs.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')):\\\\\\\\\\\\\\\\n                history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{outputs}")\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[22]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting notebook history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[23]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nnb_hist = get_notebook_history(max_cells=20)\\\\\\\\\\\\\\\\nnb_hist\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'text/plain\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': ["[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[0]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| default_exp core\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[1]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| hide\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom nbdev.showdoc import *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[2]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom dotenv import load_dotenv\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic import BaseModel, Field\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic_ai import Agent, ModelRetry, RunContext\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pydantic_ai.models import KnownModelName\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nload_dotenv()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Enable async/await in Jupyter\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport nest_asyncio\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnest_asyncio.apply()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[3]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom datetime import date\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nsystem_prompt = f"""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou are a helpful assistant that operates in a Jupyter notebook.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYour regular text responses are rendered as cell output.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can create new cells, edit existing cells, and run code.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nYou can also use tools to help you with your tasks.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nToday\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s date is {date.today().strftime(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%Y-%m-%d\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')}.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n"""\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[4]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import cast\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmodel = cast(KnownModelName, os.getenv(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PYDANTIC_AI_MODEL\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'openai:gpt-4o\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'PydanticAI is using model: {model}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnotebook_agent = Agent(model, system_prompt=system_prompt)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[5]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef refresh_agent():\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    global notebook_agent\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    notebook_agent = Agent(model, system_prompt=system_prompt)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return notebook_agent\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[6]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom IPython.display import display, Markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import Literal\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n@notebook_agent.tool\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef create_cell(ctx: RunContext[str], content: str, cell_type: Literal[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\') -&gt; str:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Create a new cell in the notebook with the specified content.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        content: The content to put in the new cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        cell_type: Type of cell to create (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' or \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'markdown\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        A confirmation message\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except NameError:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return "Error: Not running in IPython/Jupyter environment"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Display the content immediately\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if cell_type == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # display(Markdown(f"```python\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{content}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n```"))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Set up the next cell with the content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython.set_next_input(content)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        display(Markdown(content))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    return f"Created new {cell_type} cell"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[7]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'can you create me a simple hello world functio in a new celland make sure I can run it right away to see the output?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[8]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef hello_world():\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    print(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Hello, World!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\')\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Call the function to display the output\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nhello_world()",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[9]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync("Create a function that calculates the factorial of a number with input validation")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[10]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef factorial(number):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Input validation to check if the number is a non-negative integer\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if not isinstance(number, int):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError("Input must be an integer.")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if number &lt; 0:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        raise ValueError("Input must be a non-negative integer.")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Base case: factorial of 0 or 1 is 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    if number == 0 or number == 1:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    # Recursive case: n! = n * (n-1)!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    else:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return number * factorial(number - 1)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Example usage\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(factorial(5))  # Output: 120\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(factorial(0))  # Output: 1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Uncomment the following lines to test input validation\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# print(factorial(-1))  # Should raise ValueError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# print(factorial(3.5))  # Should raise ValueError\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' "Cell[11]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult = notebook_agent.run_sync(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'So what you just made for me here?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', message_history=result.new_messages())\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nMarkdown(result.data)",\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[12]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nresult.all_messages()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[13]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport os\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport json\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom pathlib import Path\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfrom typing import Optional, Dict, Any\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Cache for notebook data\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n_notebook_cache: Dict[str, Any] = {}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef find_current_notebook() -&gt; Optional[dict]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Find and cache the current notebook data.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        Dict containing notebook data or None if not found\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    global _notebook_cache\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get current cell content to identify the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_cell = ipython.get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Check if we already found the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' in _notebook_cache:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Verify it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s still the correct notebook by checking the current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            notebook = _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    return notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # If not in cache or cache is invalid, search for the notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_dir = Path.cwd()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        notebook_files = list(current_dir.glob("*.ipynb"))\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for nb_file in notebook_files:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                with open(nb_file) as f:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    notebook = json.load(f)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    for cell in notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                        if (cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) == current_cell):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            # Found the notebook, cache it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            _notebook_cache[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] = nb_file\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                            return notebook\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            except Exception:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                continue\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        print(f"Error finding notebook: {e}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return None\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'Cell[14]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef get_notebook_history(max_cells: int = 5) -&gt; list:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """Get the content of notebook cells between current and last prompt cell.\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        max_cells: Maximum number of previous cells to include\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        List of previous cell contents\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get the cached notebook or find it\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        notebook = find_current_notebook()\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if not notebook:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Find current cell index\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_cell = get_ipython().get_parent()[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'content\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'][\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        cells = notebook[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        current_idx = -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        last_prompt_idx = -1\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Find current cell and last prompt cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for idx, cell in enumerate(cells):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            source = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']) if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], list) else cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Find current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if current_idx == -1 and cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source == current_cell:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                current_idx = idx\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            # Find last prompt cell before current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if idx &lt; current_idx or current_idx == -1:  # Only look at cells before current\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' and source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    last_prompt_idx = idx\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if current_idx == -1:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        # Get cells between last prompt and current cell\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        start_idx = last_prompt_idx + 1 if last_prompt_idx != -1 else max(0, current_idx - max_cells)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        history = []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        for idx in range(start_idx, current_idx):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            cell = cells[idx]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n            if cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'cell_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] == \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'code\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\':  # Only include code cells\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                # Skip cells that are prompt cells and nbdev directives\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                source = cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'] if isinstance(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'], str) else \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.join(cell[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'source\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'])\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                if not source.strip().startswith(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'%%prompt\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'):\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    history.append(f"Cell[{idx}]:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n{source}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return history\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        print(f"Error getting notebook history: {e}")\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        return []\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\']}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execution_count\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': 58, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'metadata\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': {}, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'output_type\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\': \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'execute_result\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'}]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[24]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n### Creating history-aware prompt\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[25]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\n#| export\\\\\\\\\\\\\\\\ndef create_history_aware_prompt(prompt: str, message_history: list = None, max_history: int = 5) -&gt; tuple:\\\\\\\\\\\\\\\\n    """Create a prompt with notebook history context and message history.\\\\\\\\\\\\\\\\n    \\\\\\\\\\\\\\\\n    Args:\\\\\\\\\\\\\\\\n        prompt: The user\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s prompt\\\\\\\\\\\\\\\\n        message_history: Previous conversation messages from results.all_messages()\\\\\\\\\\\\\\\\n        max_history: Maximum number of previous cells to include\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    Returns:\\\\\\\\\\\\\\\\n        Tuple of (enhanced prompt, combined message history)\\\\\\\\\\\\\\\\n    """\\\\\\\\\\\\\\\\n    try:\\\\\\\\\\\\\\\\n        ipython = get_ipython()\\\\\\\\\\\\\\\\n        if not ipython:\\\\\\\\\\\\\\\\n            return prompt, message_history\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Get new cells using our optimized get_notebook_history\\\\\\\\\\\\\\\\n        new_cells = get_notebook_history(max_cells=max_history)\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        if not new_cells and not message_history:\\\\\\\\\\\\\\\\n            return prompt, None\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n        # Create message history if none exists\\\\\\\\\\\\\\\\n        from pydantic_ai.messages import (\\\\\\\\\\\\\\\\n            ModelRequest, ModelResponse, \\\\\\\\\\\\\\\\n            UserPromptPart, TextPart\\\\\\\\\\\\\\\\n        )\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        messages = []\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Add existing message history if provided\\\\\\\\\\\\\\\\n        if message_history:\\\\\\\\\\\\\\\\n            messages.extend(message_history)\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n        # Only add context message if we have new cells\\\\\\\\\\\\\\\\n        if new_cells:\\\\\\\\\\\\\\\\n            # Create context message with new cells\\\\\\\\\\\\\\\\n            history_content = "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n".join(new_cells)\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n            context_msg = ModelRequest(parts=[\\\\\\\\\\\\\\\\n                UserPromptPart(\\\\\\\\\\\\\\\\n                    content="Here is the context of new notebook cells that were added:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n" + history_content\\\\\\\\\\\\\\\\n                )\\\\\\\\\\\\\\\\n            ])\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            # Create response acknowledging new context\\\\\\\\\\\\\\\\n            context_response = ModelResponse(parts=[\\\\\\\\\\\\\\\\n                TextPart(\\\\\\\\\\\\\\\\n                    content="I understand the new notebook context. How can I help?"\\\\\\\\\\\\\\\\n                )\\\\\\\\\\\\\\\\n            ])\\\\\\\\\\\\\\\\n            \\\\\\\\\\\\\\\\n            messages.extend([context_msg, context_response])\\\\\\\\\\\\\\\\n                \\\\\\\\\\\\\\\\n        return prompt, messages\\\\\\\\\\\\\\\\n        \\\\\\\\\\\\\\\\n    except Exception as e:\\\\\\\\\\\\\\\\n        print(f"Error creating history-aware prompt: {e}")\\\\\\\\\\\\\\\\n        return prompt, message_history\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\n[]\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\nCell[26]:\\\\\\\\\\\\\\\\nSource:\\\\\\\\\\\\\\\\nTesting history-aware prompt\\\\\\\\\\\\\\\\nOutputs:\\\\\\\\\\\\\\\\nNone\\\\\\\\\\\\\\\', timestamp=datetime.datetime(2024, 12, 31, 8, 26, 5, 737496, tzinfo=datetime.timezone.utc), part_kind=\\\\\\\\\\\\\\\'user-prompt\\\\\\\\\\\\\\\')], kind=\\\\\\\\\\\\\\\'request\\\\\\\\\\\\\\\'),\\\\\\\\n\\\\\\\', "  ModelResponse(parts=[TextPart(content=\\\\\\\'I understand the new notebook context. How can I help?\\\\\\\', part_kind=\\\\\\\'text\\\\\\\')], timestamp=datetime.datetime(2024, 12, 31, 8, 26, 5, 737510, tzinfo=datetime.timezone.utc), kind=\\\\\\\'response\\\\\\\')])"]}, \\\\\\\'execution_count\\\\\\\': 30, \\\\\\\'metadata\\\\\\\': {}, \\\\\\\'output_type\\\\\\\': \\\\\\\'execute_result\\\\\\\'}]\\\\n\\\\nCell[30]:\\\\nSource:\\\\n### Running agent with notebook history\\\\nOutputs:\\\\nNone\\\\n\\\\nCell[31]:\\\\nSource:\\\\n#| export\\\\nfrom typing import Any\\\\ndef run_with_history(agent: Agent, prompt: str, message_history: list = None, max_history: int = 5) -&gt; Any:\\\\n    """Run the agent with notebook and conversation history context.\\\\n    \\\\n    Args:\\\\n        agent: The PydanticAI agent\\\\n        prompt: The user\\\\\\\'s prompt\\\\n        message_history: Previous conversation messages\\\\n        max_history: Maximum number of previous cells to include\\\\n        \\\\n    Returns:\\\\n        Agent run result\\\\n    """\\\\n    prompt, combined_history = create_history_aware_prompt(\\\\n        prompt, \\\\n        message_history=message_history, \\\\n        max_history=max_history\\\\n    )\\\\n    return agent.run_sync(prompt, message_history=combined_history)\\\\nOutputs:\\\\n[]\\\\n\\\\nCell[32]:\\\\nSource:\\\\nTesting run_with_history\\\\nOutputs:\\\\nNone\\\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976699, tzinfo=datetime.timezone.utc), part_kind=\\\'user-prompt\\\')], kind=\\\'request\\\'),\\n\', " ModelResponse(parts=[TextPart(content=\'I understand the new notebook context. How can I help?\', part_kind=\'text\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976722, tzinfo=datetime.timezone.utc), kind=\'response\'),\\n", " ModelRequest(parts=[UserPromptPart(content=\'So what is going on in this notebook?\', timestamp=datetime.datetime(2024, 12, 31, 12, 53, 37, 976975, tzinfo=datetime.timezone.utc), part_kind=\'user-prompt\')], kind=\'request\'),\\n", \' ModelResponse(parts=[TextPart(content=\\\'This notebook appears to be part of a system that uses an AI agent to automate tasks within a Jupyter notebook. Here are some key points:\\\\n\\\\n1. **AI Agent Integration**: The notebook is integrating a Pydantic AI model, specifically an agent that seems to respond to prompts and perform tasks within the notebook environment.\\\\n\\\\n2. **Function Definitions**: Several Python functions have been defined:\\\\n   - `factorial()`: This function calculates the factorial of a number with input validation.\\\\n   - `hello_world()`: A simple function that prints "Hello, World!".\\\\n   \\\\n3. **Cell Creation and Management**: There are functions and tools implemented to create and manage notebook cells programmatically. For example, the `create_cell` function uses the IPython\\\\\\\'s API to insert new cells.\\\\n\\\\n4. **Notebook History Management**: The notebook implements functionality to keep track of the history of executed notebook cells, which can be used to provide context to the AI agent.\\\\n\\\\n5. **History-Aware Prompts**: Functions like `create_history_aware_prompt` are used to create prompts that include historical context from the notebook. This allows the AI to make more informed decisions by understanding previous interactions and code.\\\\n\\\\n6. **Testing and Execution**: The notebook includes cells dedicated to testing these features, like running the agent with notebook history and testing the factorial function.\\\\n\\\\nOverall, it seems to be an experimental setup aiming to enhance interaction with a Jupyter notebook using AI for improved productivity and dynamic task execution.\\\', part_kind=\\\'text\\\')], timestamp=datetime.datetime(2024, 12, 31, 12, 53, 39, tzinfo=datetime.timezone.utc), kind=\\\'response\\\')]\']}, \'execution_count\': 23, \'metadata\': {}, \'output_type\': \'execute_result\'}]\n\nCell[37]:\nSource:\n#| export\n@notebook_agent.tool\ndef modify_cell(ctx: RunContext[str], cell_index: int, content: str) -&gt; str:\n    """Modify an existing cell in the notebook.\n    \n    Args:\n        cell_index: The index of the cell to modify\n        content: The new content for the cell\n        \n    Returns:\n        A confirmation message\n    """\n    try:\n        notebook = find_current_notebook()\n        if not notebook:\n            return "Error: Could not find current notebook"\n            \n        cells = notebook[\'cells\']\n        if cell_index &lt; 0 or cell_index &gt;= len(cells):\n            return f"Error: Cell index {cell_index} is out of range"\n            \n        # Get the cell\n        cell = cells[cell_index]\n        \n        # Update the cell content in IPython\n        ipython = get_ipython()\n        if not ipython:\n            return "Error: Not running in IPython environment"\n            \n        # Set the content of the specified cell\n        ipython.set_next_input(content, replace=True)\n        \n        return f"Modified cell {cell_index} with new content"\n        \n    except Exception as e:\n        return f"Error modifying cell: {str(e)}"\nOutputs:\n[{\'name\': \'stderr\', \'output_type\': \'stream\', \'text\': [\'&lt;module&gt;:8: No type or annotation for returned value 1\\n\']}, {\'ename\': \'UserError\', \'evalue\': "Tool name conflicts with existing tool: \'modify_cell\'", \'output_type\': \'error\', \'traceback\': [\'\\x1b[0;31m---------------------------------------------------------------------------\\x1b[0m\', \'\\x1b[0;31mUserError\\x1b[0m                                 Traceback (most recent call last)\', \'Cell \\x1b[0;32mIn[42], line 2\\x1b[0m\\n\\x1b[1;32m      1\\x1b[0m \\x1b[38;5;66;03m#| export\\x1b[39;00m\\n\\x1b[0;32m----&gt; 2\\x1b[0m \\x1b[38;5;129;43m@notebook_agent\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43mtool\\x1b[49m\\n\\x1b[1;32m      3\\x1b[0m \\x1b[38;5;28;43;01mdef\\x1b[39;49;00m\\x1b[43m \\x1b[49m\\x1b[38;5;21;43mmodify_cell\\x1b[39;49m\\x1b[43m(\\x1b[49m\\x1b[43mctx\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mRunContext\\x1b[49m\\x1b[43m[\\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m]\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mcell_index\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mint\\x1b[39;49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mcontent\\x1b[49m\\x1b[43m:\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m)\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;241;43m-\\x1b[39;49m\\x1b[38;5;241;43m&gt;\\x1b[39;49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43mstr\\x1b[39;49m\\x1b[43m:\\x1b[49m\\n\\x1b[1;32m      4\\x1b[0m \\x1b[38;5;250;43m    \\x1b[39;49m\\x1b[38;5;124;43;03m"""Modify an existing cell in the notebook.\\x1b[39;49;00m\\n\\x1b[1;32m      5\\x1b[0m \\x1b[38;5;124;43;03m    \\x1b[39;49;00m\\n\\x1b[1;32m      6\\x1b[0m \\x1b[38;5;124;43;03m    Args:\\x1b[39;49;00m\\n\\x1b[0;32m   (...)\\x1b[0m\\n\\x1b[1;32m     11\\x1b[0m \\x1b[38;5;124;43;03m        A confirmation message\\x1b[39;49;00m\\n\\x1b[1;32m     12\\x1b[0m \\x1b[38;5;124;43;03m    """\\x1b[39;49;00m\\n\\x1b[1;32m     13\\x1b[0m \\x1b[43m    \\x1b[49m\\x1b[38;5;28;43;01mtry\\x1b[39;49;00m\\x1b[43m:\\x1b[49m\\n\', \'File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:683\\x1b[0m, in \\x1b[0;36mAgent.tool\\x1b[0;34m(self, func, retries, prepare)\\x1b[0m\\n\\x1b[1;32m    680\\x1b[0m     \\x1b[38;5;28;01mreturn\\x1b[39;00m tool_decorator\\n\\x1b[1;32m    681\\x1b[0m \\x1b[38;5;28;01melse\\x1b[39;00m:\\n\\x1b[1;32m    682\\x1b[0m     \\x1b[38;5;66;03m# noinspection PyTypeChecker\\x1b[39;00m\\n\\x1b[0;32m--&gt; 683\\x1b[0m     \\x1b[38;5;28;43mself\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43m_register_function\\x1b[49m\\x1b[43m(\\x1b[49m\\x1b[43mfunc\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[38;5;28;43;01mTrue\\x1b[39;49;00m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mretries\\x1b[49m\\x1b[43m,\\x1b[49m\\x1b[43m \\x1b[49m\\x1b[43mprepare\\x1b[49m\\x1b[43m)\\x1b[49m\\n\\x1b[1;32m    684\\x1b[0m     \\x1b[38;5;28;01mreturn\\x1b[39;00m func\\n\', \'File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:765\\x1b[0m, in \\x1b[0;36mAgent._register_function\\x1b[0;34m(self, func, takes_ctx, retries, prepare)\\x1b[0m\\n\\x1b[1;32m    763\\x1b[0m retries_ \\x1b[38;5;241m=\\x1b[39m retries \\x1b[38;5;28;01mif\\x1b[39;00m retries \\x1b[38;5;129;01mis\\x1b[39;00m \\x1b[38;5;129;01mnot\\x1b[39;00m \\x1b[38;5;28;01mNone\\x1b[39;00m \\x1b[38;5;28;01melse\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_default_retries\\n\\x1b[1;32m    764\\x1b[0m tool \\x1b[38;5;241m=\\x1b[39m Tool(func, takes_ctx\\x1b[38;5;241m=\\x1b[39mtakes_ctx, max_retries\\x1b[38;5;241m=\\x1b[39mretries_, prepare\\x1b[38;5;241m=\\x1b[39mprepare)\\n\\x1b[0;32m--&gt; 765\\x1b[0m \\x1b[38;5;28;43mself\\x1b[39;49m\\x1b[38;5;241;43m.\\x1b[39;49m\\x1b[43m_register_tool\\x1b[49m\\x1b[43m(\\x1b[49m\\x1b[43mtool\\x1b[49m\\x1b[43m)\\x1b[49m\\n\', "File \\x1b[0;32m~/WebDev/FH_SQLModel/.venv/lib/python3.12/site-packages/pydantic_ai/agent.py:774\\x1b[0m, in \\x1b[0;36mAgent._register_tool\\x1b[0;34m(self, tool)\\x1b[0m\\n\\x1b[1;32m    771\\x1b[0m     tool \\x1b[38;5;241m=\\x1b[39m dataclasses\\x1b[38;5;241m.\\x1b[39mreplace(tool, max_retries\\x1b[38;5;241m=\\x1b[39m\\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_default_retries)\\n\\x1b[1;32m    773\\x1b[0m \\x1b[38;5;28;01mif\\x1b[39;00m tool\\x1b[38;5;241m.\\x1b[39mname \\x1b[38;5;129;01min\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_function_tools:\\n\\x1b[0;32m--&gt; 774\\x1b[0m     \\x1b[38;5;28;01mraise\\x1b[39;00m exceptions\\x1b[38;5;241m.\\x1b[39mUserError(\\x1b[38;5;124mf\\x1b[39m\\x1b[38;5;124m\'\\x1b[39m\\x1b[38;5;124mTool name conflicts with existing tool: \\x1b[39m\\x1b[38;5;132;01m{\\x1b[39;00mtool\\x1b[38;5;241m.\\x1b[39mname\\x1b[38;5;132;01m!r}\\x1b[39;00m\\x1b[38;5;124m\'\\x1b[39m)\\n\\x1b[1;32m    776\\x1b[0m \\x1b[38;5;28;01mif\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_result_schema \\x1b[38;5;129;01mand\\x1b[39;00m tool\\x1b[38;5;241m.\\x1b[39mname \\x1b[38;5;129;01min\\x1b[39;00m \\x1b[38;5;28mself\\x1b[39m\\x1b[38;5;241m.\\x1b[39m_result_schema\\x1b[38;5;241m.\\x1b[39mtools:\\n\\x1b[1;32m    777\\x1b[0m     \\x1b[38;5;28;01mraise\\x1b[39;00m exceptions\\x1b[38;5;241m.\\x1b[39mUserError(\\x1b[38;5;124mf\\x1b[39m\\x1b[38;5;124m\'\\x1b[39m\\x1b[38;5;124mTool name conflicts with result schema name: \\x1b[39m\\x1b[38;5;132;01m{\\x1b[39;00mtool\\x1b[38;5;241m.\\x1b[39mname\\x1b[38;5;132;01m!r}\\x1b[39;00m\\x1b[38;5;124m\'\\x1b[39m)\\n", "\\x1b[0;31mUserError\\x1b[0m: Tool name conflicts with existing tool: \'modify_cell\'"]}]\n\nCell[38]:\nSource:\n\nOutputs:\n[]\n\nCell[39]:\nSource:\n### Creating prompt cell magic\nOutputs:\nNone\n\nCell[40]:\nSource:\n#| export\nfrom IPython.core.magic import register_cell_magic\n\n#| export\n@register_cell_magic\ndef prompt(line, cell):\n    """Cell magic to create prompt cells that interact with the AI agent."""\n    try:\n        # Get the last result\'s message history if it exists\n        message_history = None\n        if \'last_prompt_result\' in get_ipython().user_ns:\n            last_result = get_ipython().user_ns[\'last_prompt_result\']\n            if hasattr(last_result, \'all_messages\'):\n                message_history = last_result.all_messages()\n        \n        # Use get_current_agent() instead of notebook_agent directly\n        agent = get_current_agent()\n        \n        # Run the prompt through our agent with history context\n        result = run_with_history(\n            agent, \n            cell.strip(), \n            message_history=message_history\n        )\n        \n        # Store the result for next time\n        get_ipython().user_ns[\'last_prompt_result\'] = result\n        \n        return Markdown(result.data)\n    except Exception as e:\n        return f"Error processing prompt: {str(e)}"\nOutputs:\n[]', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436565, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content='I understand the new notebook context. How can I help?', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436588, tzinfo=datetime.timezone.utc), kind='response'),
 ModelRequest(parts=[UserPromptPart(content='what this notebook is all about?', timestamp=datetime.datetime(2024, 12, 31, 13, 10, 59, 436914, tzinfo=datetime.timezone.utc), part_kind='user-prompt')], kind='request'),
 ModelResponse(parts=[TextPart(content='This notebook appears to be part of a system that uses an AI agent to automate tasks within a Jupyter notebook. Here are some key points:\n\n1. **AI Agent Integration**: The notebook is integrating a Pydantic AI model, specifically an agent that seems to respond to prompts and perform tasks within the notebook environment.\n\n2. **Function Definitions**: Several Python functions have been defined:\n   - `factorial()`: This function calculates the factorial of a number with input validation.\n   - `hello_world()`: A simple function that prints "Hello, World!".\n\n3. **Cell Creation and Management**: There are functions and tools implemented to create and manage notebook cells programmatically. For example, the `create_cell` function uses the IPython\'s API to insert new cells.\n\n4. **Notebook History Management**: The notebook implements functionality to keep track of the history of executed notebook cells, which can be used to provide context to the AI agent.\n\n5. **History-Aware Prompts**: Functions like `create_history_aware_prompt` are used to create prompts that include historical context from the notebook. This allows the AI to make more informed decisions by understanding previous interactions and code.\n\n6. **Testing and Execution**: The notebook includes cells dedicated to testing these features, like running the agent with notebook history and testing the factorial function.\n\nOverall, it seems to be an experimental setup aiming to enhance interaction with a Jupyter notebook using AI for improved productivity and dynamic task execution.', part_kind='text')], timestamp=datetime.datetime(2024, 12, 31, 13, 11, 33, tzinfo=datetime.timezone.utc), kind='response')]</code></pre>
</div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ndendic\.github\.io\/jupy-juice");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/ndendic/jupy-juice/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>